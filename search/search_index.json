{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ZeroDiff","text":"<p>View the latest posts.</p>"},{"location":"#a-new-way-to-design-and-develop-products","title":"A New Way to Design and Develop Products","text":""},{"location":"#a-simple-philosophy","title":"A Simple Philosophy","text":"<p>If you maintain zero difference between prototype and production designs, you can release or mass produce any revision even when you iterate designs rapidly.</p>"},{"location":"#corollary","title":"Corollary","text":"<p>Always manufacture prototype and production designs with the same process and tooling - always.</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#philosophy","title":"Philosophy","text":"<p>If you maintain zero difference between prototype and production, you can release any revision even when iterating rapidly.</p>"},{"location":"#impact","title":"Impact","text":"<ul> <li>For Software: your dev cluster is production. Every commit can go live.</li> <li>For Hardware: your enclosures and PCBs use production tooling. Every revision is manufacturing-ready.</li> </ul>"},{"location":"#result","title":"Result","text":"<p>Iterate with real users in days, not months. No \"big bang\" releases. Scale at any moment.</p>"},{"location":"#explore","title":"Explore","text":"<p>Here are a couple of ways that you can explore the concepts:</p> <p>New to ZeroDiff: Start with Principles</p> <p>Dive deep: Hardware or Software guides</p> <p>Follow the journey: Posts</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#glossary","title":"Glossary","text":"Term Description Example AMT Automated Monkey Testing - The equivalent of TDD/CI for software - usually run in a fixed jig directly from firmware commits. Assembly File (Assy) Complete assembly instructions for a WIP or finished good item.  LED tube assembly instructions Assembly File This is a Word document with images that explains how to do any special assembly to and item. Bill of Materials (BOM) A list of component parts needed in a kit to build a WIP or finished good part. Components needed to build a particular PCBA. Centroid File A machine file used to show the centers of ICs placed on a PCB by a pick-and-place machine Contract Manufacturing Service (CMS) A company that manufactures products on behalf of another company. DXF or EPS Output file Autodesk format vector file - allows transmission of 2d build data to computer aided laser or water cutting. Engineer Design or production engineer Engineering Change Order A document that details all of the changes between two revisions or versions.  It should reference the revision numbers and the changes made between each release.  The CMS is not allowed to make any changes to this package, including vendor or part substitutions, without first looping back to Codeshelf with an ECO. Engineering Change Request An ECR is initiated by a CMS to suggest a change to a released device. The ECR initiates a process of discussion within the organization to determine the impact of a change and the best possible solution, potentially resulting in an ECO. Excellon (Drill) File A machine file used to generate PCB vias and holes. Fabrication facility (Fab) A factory that manufactures components, typically PCBs or semiconductor devices. Finished Good A complete item ready for installation or sale. Aisle Controller First Article Goods made to test whether the entire release and manufacturing process is sound. These items should be considered completely production-ready. These releases include submitting a Purchase Order to an external vendor. Flash/Test Jig A device used to optionally flash and then test a WIP or finished good item during manufacture. Gerber File A machine file used to generate PCB copper layers. Git commit A specific document version committed to git for tracking and sharing. Git tag A named tag associated with any git commit. Git A revision system for tracking document versions through time HWTE Hardware Test Engineer Kitting Combining raw material and WIP into a kit to send to a value add step or to a customer. A box of parts to make one or more CHEs Mechanicals Many of our housings are currently assembled in house, but for larger manufacturing runs we need to include an assembly file to let the 3<sup>rd</sup> party manufacturers know how to assemble the items. For mechanical releases this file may be a step-by-step instruction manual with images and text describing the assembly process. Minimum Order Quantity (MoQ) The smallest number of units a manufacturer will produce in a single production run. PCB Fabrication File Instructions on how to manufacture PCB files. Includes notes, UL data, clarifications, revisions, etc. PCB Stackup The number of copper and fiberglass layers, the copper weights, solder mask type/color and silkscreen color. PCBAs Most of our boards can get built entirely in the pick-and-place robots, but if there is some unusual hand-assembly step, etc. then we need to include an assembly file to let the 3<sup>rd</sup> party manufacturers know how to do these steps. PDF Drawing File Essentially a Fabrication file for the mechanicals, containing all dimensions, tolerances, material requirements, etc. for the build.  This is the document a vendor will use to QA a built item.  It is also our assurance of recourse for any incorrect items we may receive. ProdMgr Production Manager Prototype Items made internally or externally that are not official production designs. These are not repeatable - they will never be re-made. Prototypes are internal engineering and test development only. Raw Material Any 3<sup>rd</sup> party item that we purchase and store unaltered. LED strips Release Package A set of immutable documents that specify how to manufacture and test a particular version of a WIP or finished good item. Release An official release of a design from engineering to production for manufacture. Revision/Version    A named, tracked change to a previous release. SLDPRT, STEP and/or IGES File The native format used by Solidworks to represent 3D geometry. STEP and IGES are portable file formats that are commonly used to represent this same geometry for the purpose of transmitting 3D design intent to a vendor. STEP is a better format than IGES and is preferred by most vendors. Best practices include sending both SLDPRT and STEP (or IGES) files in case the vendor is using a different version of Solidworks\u2014which is not backward-forward compatible. Stereolithography File (STL) STL files describe only the surface geometry of a three-dimensional object without any representation of color, texture or other common CAD model attributes. The STL format specifies both ASCII and binary representations. It is widely used for rapid prototyping and computer-aided manufacturing. Test File This is a Word document file that explains how to flash (optional) and test a WIP or finished goods item during manufacture.  This document is critical because it indicates our quality acceptance criteria from the manufacturer before they ship the part.  Any flaws found after delivery are expensive to resolve and may cost us instead of the 3<sup>rd</sup> party. Value Add A manufacture step or process where Codeshelf modifies one or more raw materials into a WIP or finished good. Cut holes in NEMA enclosures Work In Process (WIP) Raw materials (or other WIP) that have been through a value-add step. NEMA enclosures with holes cut in them"},{"location":"about/contribute/","title":"Contribute","text":""},{"location":"about/contribute/#contribute","title":"Contribute","text":"<p>I wrote the ZeroDiff docs using mkdocs and committed it all to github. This setup not only generates nice-looking, searchable documentation, it makes it possible to share/fork it so that ZeroDiff can be a community effort.</p> <p>The mkdocs system is a self-contained, Python-based documentation tool that uses Twitter Bootstrap and scripting to generate high-quality HTML-based documentation using simple markdown files. The cool thing about mkdocs is that the repo is both the documentation set and place to generate the static, production site. The top-level mkdocs.yml file shows the documentation tree structure and configurations. If you edit this file, it will be pretty easy to see what markdown (*.md) files you need to edit in order to change the docs you want changed.</p>"},{"location":"about/contribute/#installing-python-and-mkdocs","title":"Installing Python and mkdocs.","text":"<p>Please see the mkdocs website to see how to install Python and the mkdocs tools. It's pretty simple and easy to do this, but it's out-of-scope to explain that here.</p>"},{"location":"about/contribute/#editing-the-docs","title":"Editing the docs","text":"<p>From a terminal session change to the top-level directory</p> <pre><code>    &gt;cd ~/git/zerodiff\n    &gt;mkdocs serve\n</code></pre> <p>Now from your browser go to the URL: http://127.0.0.1:8000</p> <p>As you edit the markdown files, mkdocs automatically updates the website in realtime so that you can review your changes.</p>"},{"location":"about/contribute/#generating-the-static-documentation-website","title":"Generating the Static Documentation Website","text":"<p>Once you've completed all of your edits, you need to generate the static site (not committed to git because \"./site\" is in .gitignore).</p> <pre><code>    &gt;cd ~/git/zerodiff\n    &gt;mkdocs build\n</code></pre> <p>This will generate a static documentation site in the directory ~/git/zerodiff/site. You can validate the site by killing the \"mkdocs serve\" process and starting a simple Python=-based web server in that directory:</p> <pre><code>    &gt;cd ~/git/zerodiff/site\n    &gt;python -m SimpleHTTPServer 8000\n</code></pre> <p>Now from your browser go to the URL: http://127.0.0.1:8000</p>"},{"location":"about/contribute/#commit-the-static-site-to-github-project-pages-gh-pages","title":"Commit the Static Site to Github Project Pages (\"gh-pages\")","text":"<pre><code>    &gt;cd ~/git/zerodiff\n    &gt;mkdocs gh-deploy --clean\n</code></pre> <p>This command will generate the static site and push it to the gh-pages branch so that it shows up as a searchable, shred website (on github). The url will be https://your_github_id.github.io/zerodiff/.</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#bsd-license","title":"BSD License","text":"<p>Copyright \u00a9 2025, Jeff Williams All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of the  nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission. <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},{"location":"about/overview/","title":"About ZeroDiff","text":"<p>For years, this site focused on hardware\u2014how to iterate PCBs and enclosures the way software teams iterate code. After work in both domains, I realize they solve similar problems in parallel, often unaware of each other's solutions.</p> <p>After a long break, I've expanded this to cover both. The hardware guides are more developed because that's where I've spent more time. Software insights will build over time, informed by the same zerodiff principles.</p> <p>Both industries can learn from each other, and I learn when I write about both.</p>"},{"location":"about/why/","title":"Why ZeroDiff?","text":"<p>In 2011 I started a side-project that would become my next startup: an innovative, low-power, cloud-controlled IoT device applied to e-commerce logistics and automation. Prior to 2011 I knew nothing about electrical, hardware or radio engineering. I tapped the many sites (Sparkfun, Instructables, Stack-Exchange, etc.) that explained how \"makers\" like me could learn to build hardware, and within 12 months I had a cloud-controlled hardware system complete enough to conduct my first pilot project. After we completed the pilot and collected all of the usability data, it was clear that \"version 2\" was going to be almost as much work to design/build as \"version 1!\"</p> <p>What these sites don't explain is how to build a hardware business!</p> <p>Undeterred, we pressed on. Version 2 took almost six more months! The product was starting to look pro and we were able to raise money to become a real company. A frustrating problem was that more people and money had almost no material impact on our ability to rapidly innovate hardware designs. We would think, \"Oh, if the product could do X, then it would be awesome.\" We knew X wouldn't see the light of day for almost a year, and there was a growing pile of X-like feature requests. It was depressing. Right around this time, my wife asked me to clear out of the home shop so that our boys could have a big play space. That meant hauling to work a CNC mill and a bunch of tools. That same week we learned of our first opportunity to create an \"add on\" product to our system, but we didn't have 6-12 months to do it. The opportunity would disappear in 8-12 weeks. We went online to see if it was possible to create sophisticated SMT/SMD circuit boards on a CNC mill, and sure enough we found a tutorial for our exact mill. We hired a skilled machinist, and within two weeks we could generate a completed PCB/A in just a few days. At that time we used off-the-shelf enclosures that were expensive and ugly (to us by now). We decided to create a formal design studio and hired our design consultant to run it. He devised a system where we could build new enclosures in a CNC mill following a layer-by-layer stack-up process. This enabled us to create fairly complex, but good looking enclosures with features, like undercuts, that you normally can't create from a single, milled part. Eventually, we developed our design process further to incorporate folded steel to greatly increase our iteration and manufacture rate while bringing costs way down. The tooling we used is not expensive: likely you could recreate our entire shop for $50K, and a light-duty version of it for less than $25K.</p> <p>Over the course of a year we formalized this process into a set of internal processes and documentation we called ZeroDiff. Through these process improvements we were able to complete production-ready hardware design revisions in as little as 48 hours. Working with local vendor/partners we were able to source all of the components to make tens of thousands of sophisticated radio control systems entirely in our downtown Oakland office. </p>"},{"location":"about/why/#now-to-share-it","title":"Now to Share it","text":"<p>We had always intended to share our ZeroDiff process, but there just never seemed to be a good way (or time) to do it. All of the company docs were trapped in Confluence, which is not a particularly great system (not forkable, and now long on tooth). We really wanted this stuff to live in github, so that the community could share and possibly grow it without a lot of inter-organization coordination. Once we found mkdocs, it seemed clear this was the right way forward.</p>"},{"location":"about/why/#a-work-in-progress","title":"A Work In Progress","text":"<p>Because we only lightly edited these documents as we extracted them, they still may have the company stink on them. They might also be incomplete, because it's just not possible to collect all the weird loose ends from our company system since it was spread across Confluence, Google Docs, Email and Jira. This is just a starting point, and we hope we all can grow this together.</p>"},{"location":"about/why/#zerodiff-is-not-for-everyone","title":"ZeroDiff is not for Everyone","text":"<p>We find that about 20% of the folks who hear about ZeroDiff \"get it\" and would like to embrace it. There's no mission to sell ZeroDiff, and we recognize there's many ways to reach the same end in product development. It's just a simple idea, and never really should be complex. There's a certain kind of product auteur nowadays who seem to do it all, and they're fascinating no matter what process they follow.</p>"},{"location":"about/why/#make-it-local-wherever-local-is","title":"Make it Local Wherever Local is","text":"<p>Finally, probably the most important part of ZeroDiff is that you can design and build a product close to the user wherever they are. This is the thing that excites me the most because we believe it unlocks a world where low-volume, high-value products can thrive **.</p> <p>  ** For the non-economic definitions of value: basically when there's no money in making people's lives better.</p>"},{"location":"blog/2025/11/22/return-to-zerodiff/","title":"Return to ZeroDiff","text":"<p>After a near decade-long break, I've returned to ZeroDiff with a new perspective: it isn't just for hardware, it's a universal approach to product design and iteration. When we got clobbered in 2016 I needed a break, so I became a contractor with a focus on cloud compute, systems programming and data systems. I shaped that work into a what I thought might be a startup, Karrots, but with two kids in college I needed to give everyone a couple years break from startup stress and grind.</p> <p>Eventually I want to return to robots and hardware, but because my life these days is mostly systems software at scale, I want to share some of the way that I have applied ZeroDiff to software over the years. The goal now is to run more formal experiments and write about them.</p> <p>The fundamental driver to my thinking is a concept I call \"the inventory cost of a git commit.\" I will write more deeply about this in the future, but the basic idea is the same as hardware: git commits are like inventory, until you ship them, they generate no economic value, so the carrying cost is the same as it is for hardware. Lowering inventory carrying costs improves the operational cash cycle which makes it possible to get more done with the same capital. This idea applies to BigCo as much as any startup, and to software as much as hardware \u2014 it's universal concept. I want to show that ZeroDiff is a way to make hardware and software businesses leaner and meaner.</p> <p>Stay tuned.</p>","tags":["hardware","software"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/","title":"Pelican Rides a Bicycle","text":"<p>Below are two SVG solutions to the Simon Willison's benchmark: <code>\"Generate an SVG of a pelican riding a bicycle.\"</code></p>","tags":["software","gen/ai","llm"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/#claude-sonnet-35","title":"Claude Sonnet 3.5:","text":"","tags":["software","gen/ai","llm"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/#claude-code","title":"Claude-Code:","text":"","tags":["software","gen/ai","llm"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/#what-changed","title":"What Changed?!","text":"<p>As agentic gen/ai exploded in 2025, it felt like Willison's benchmark became a solvable problem if we used these new agentic powers: skills, sub-agents, tool-use and more. Using Claude-Code, I built a pipeline that now solves this problem.</p> <p>The Github repo github.com/0x6a77/pelican-rides-a-bicycle let's you replicate this work and see an example of Claude-Code skills with tool-calling.</p>","tags":["software","gen/ai","llm"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/#how-it-works","title":"How It Works","text":"<p>The Claude-Code skills pipeline orchestrates specialized capabilities:</p> <ul> <li>Agentic/AI Orchestrates the pipeline</li> <li>Image Generation: Flux diffusion model generates a bitmap of the prompt</li> <li>Vector Tracing: autotrace converts the bitmap to SVG paths</li> </ul> <p>The agent's job is to know which tool to use when. This is fundamentally different from asking a transformer to generate SVG vectors from scratch.</p>","tags":["software","gen/ai","llm"]},{"location":"blog/2025/12/15/pelican-rides-a-bicycle/#2026-the-year-of-agentic-pipelines","title":"2026, The Year of Agentic Pipelines?","text":"<p>Some might argue this doesn't solve Willison's benchmark - it solves the problem his benchmark reveals. It shows transformers can't do one-shot compositional spatial reasoning. My pipeline shows that agentic gen/ai doesn't need to because it can orchestrate specialized tools instead. The pelican benchmark is valuable for tracking raw model capabilities, but to build systems that work today, we need orchestration.<sup>1</sup></p> <p>The right way forward with gen/ai is to embrace agentic gen/ai in 2026 in deeper and more interesting ways. Stay tuned for an expansion of this idea.</p> <ol> <li> <p>(Stephen Wolfram's work on computational irreducibility suggests the pelican task may require a level of spatial reasoning that transformers can't do, so tool orchestration isn't just pragmatic, but potentially necessary. I plan to write about this in a future post.)\u00a0\u21a9</p> </li> </ol>","tags":["software","gen/ai","llm"]},{"location":"hardware/","title":"Hardware","text":"<p>This site documents the ZeroDiff process for small teams producing high-value products at low-to-medium volumes. The goal: rapid iteration with real users. Every commit\u2014whether deploying code or shipping hardware\u2014goes live for value testing. This repeats for an ever-growing user base with ever-growing product value. Experience suggests 15 iterations reach maximal user value, so multiply your iteration cycle time by 15 to estimate when your design reaches optimal utility.</p> <p>For years, this site focused on hardware\u2014how to iterate PCBs and enclosures the way software teams iterate code. But the more I worked in both domains, the more I realized they solve similar problems in parallel, often unaware of each other's solutions. After a long break from writing, I'm expanding this documentation to cover both. The hardware sections are more developed because that's where I've spent more time. Software insights are coming, informed by the same zerodiff principles. Both industries can learn from each other, and I'm learning by writing about both.</p>"},{"location":"hardware/#in-software","title":"In Software","text":"<p>Your development cluster is identical to production. Every branch can go live. No Docker Compose hacks that diverge from production infrastructure. When you merge, you deploy, because your test environment was already production ready.</p>"},{"location":"hardware/#in-hardware","title":"In Hardware","text":"<p>Your prototype PCBs, enclosures, and interfaces use the same process and tooling as your production run. Every revision is manufacturing-ready. No \"works-like/looks-like\" splits. When you validate a design with users, you can immediately scale it.</p> <p>The Result: Rapid iteration with real users, no \"big bang\" releases, and the ability to scale at any moment.</p>"},{"location":"hardware/#examples-in-practice","title":"Examples in Practice","text":""},{"location":"hardware/#software-everything-as-a-whole-every-time","title":"Software: Everything as a Whole, Every Time!","text":"<p>Container orchestration has given us the ability to test whole systems with users, and Karrots is a way to cheaply and quickly deploy a cluster for every story. Now we can test whole systems with high user-fidelity. When it comes time to deploy the work to production, it's a simple git commit because we started with a git branch that gave us a faithful copy of the production cluster.</p>"},{"location":"hardware/#hardware-kill-the-waterfall-method-again","title":"Hardware: Kill the Waterfall Method (Again!)","text":""},{"location":"hardware/#ie-crowdsource-works-likelooks-like-shenzhen","title":"i.e. Crowdsource, Works-Like/Looks-Like, Shenzhen","text":"<p>Prior to the 2000s, software development followed a process called The Waterfall Method. Product development would follow a sequence: conception, analysis, design, construction and testing. 12-18 months might pass before users saw anything, and if they wanted changes or didn't like features, it might be another 12-18 months before they would see those changes. It was pretty awful, and no good software product designer would ever want to go back to those times. Today, software developers follow a lean or agile practice that involves small, rapid iterations with continual and close user-value testing. Each iteration allows for incremental investments targeted toward value and user growth.</p> <p>So why are hard goods designers stuck in the Waterfall Methodology? Setting aside the debate of just how easy/cheap it is to fly to Shenzhen to engage a fab/CMS in supply chain execution, there are two major problems with this approach:</p> <ul> <li>The team is working toward a single manufactured revision given imperfect user testing - a kind of Hail Mary pass.</li> <li>The product users are somewhere else, so for the factory design team, user empathy is low.</li> </ul> <p>The whole point of ZeroDiff is to rapidly iterate with the users close at hand. With traditional overseas manufacturing, a single design iteration might take 4-8 weeks (design revision \u2192 overseas sampling \u2192 shipping \u2192 user testing \u2192 feedback analysis). Under ZeroDiff, this same cycle can happen in 1-2 weeks, meaning you can complete 5-10 iterations in the time it would take for a single overseas prototype cycle. Maybe you build ten of the first version and get them into the hands of real users. This allows the product design team to evaluate the user experience and propose design changes that show up in the next iteration within 1-2 weeks. Each successive iteration grows the product value, and potentially grows the user base. Since every revision is production-ready, the development team can select any revision for mass production. At that point, if your demand is high and you need MoQ 10K production runs then it's super simple to take your latest rev to Shenzhen. The rest of us (most of us) can continue to produce economically in low-volume close to where we live.</p>"},{"location":"hardware/#permission-based-production-is-terrible","title":"Permission-based Production is Terrible","text":"<p>As small-batch production becomes less economically viable, product design teams find themselves in a permission-based production model where they have to convince a fab or CMS of the value of their job over other jobs. Most modern fabs will quickly design prototypes and produce samples in order to win larger business later, but they will not run those designs at low volume unless there's no other work on the line. To make things worse, the production-version designs and fab/assembly docs are generally not accessible to the product design team, making it painful and expensive to switch fabs.</p> <p>ZeroDiff eliminates permission-based production by giving you direct control over your manufacturing process. When you own or have reliable access to the production tooling and can manufacture economically at low volumes, you don't need to convince anyone that your 50-unit run is worthwhile. You simply produce it. This autonomy means you can iterate on your timeline, not on a fab's production schedule, and every design file remains yours to use, modify, or take elsewhere.</p>"},{"location":"hardware/#the-joy-of-high-value-at-low-volume","title":"The Joy of High-Value at Low-Volume","text":"<p>A side-effect of the ZeroDiff process is that small-batch production is something you can do economically on short development cycles and low unit volume. Traditionally, low-volume manufacturing has been prohibitively expensive, limiting production to products with clear mass-market appeal and high price points. By making small-batch production economically viable, ZeroDiff opens the door to creating products that serve niche needs or pursue goals beyond profit maximization. \"Value\" is a complex word, but in production we tend to boil it down to simple economics. What happens when an object's cost or sales price is not a major component of its value? When you can produce 10 or 100 units economically rather than needing 10,000 to justify tooling costs, that gives us the luxury to choose the many other definitions of value. Perhaps we can choose to make things because they increase our enjoyment, or relieve the suffering of others \u2014 assistive devices for rare conditions, tools for small communities, or products that prioritize sustainability over scale. The possibilities are enormous and liberating!</p>"},{"location":"hardware/beginners/design/","title":"Design","text":""},{"location":"hardware/beginners/design/#zerodiff-design-methodology-and-process","title":"ZeroDiff Design Methodology and Process","text":"<p>A good design methodology is critical to your success! We encourage you to read the entire design section, but for process you only need the section on how run a good design sprint for each dev cycle.</p> <p>Design Sprint Process</p>"},{"location":"hardware/beginners/doc_control/","title":"Document Control","text":""},{"location":"hardware/beginners/doc_control/#github-for-design-docs-and-artifacts","title":"Github for design docs and artifacts","text":"<p>We discovered that github was waaay better for managing designs, builds, BOMs, fab documents and related ephemera. Formal BOM managers and ERP systems suck. Seriously - you have no idea. Not only are they trapped in the best tech 1995 has to offer, they're overly complex and stupid expensive. Even when you hire dedicated staff to run this stuff, they struggle to keep it relevant. We found keeping the designers, engineers, QA and build teams all on the same toolchain also kept the close.</p>"},{"location":"hardware/beginners/kaizen/","title":"Kaizen","text":""},{"location":"hardware/beginners/kaizen/#from-the-read-with-a-pen-tinyletter-post","title":"From the \"Read with a Pen\" TinyLetter post.","text":"<p>https://tinyletter.com/zerodiff/letters/zerodiff-efficient-kaizen-read-with-a-pen</p> <p>Done right, Kaizen reduces mistakes and waste.  But what happens when process itself is the waste?  We all experience this: the application of process to reduce mistakes (and waste) sometimes ends up being worse than the mistakes the new process reduces!   To me, this is a central difficulty to \"being in charge.\"</p> <p>I started my career in factory automation with a mentor who embraced lean manufacturing decades ahead of its current stylishness.  I would read anything even remotely connected to 1950s-80s Toyota Motor Company.  I read \"The Machine that Changed the World\" twice.  Because my natural inclination is laziness, \"lean process\" appeals to me deeply.  So of course I'm a sucker for Eric Ries and Steve Blank's \"Lean Startup\" movement.  Ditto for \"The Pretotyping Manifesto.\"</p> <p>The key to lean operation is efficient, well-documented processes that everyone can easily follow and get right.  Our process docs work like checklists.  Checklists have been proven to prevent stupid mistakes by smart people - it's why doctors and pilots use them without exception.</p> <p>Despite a big investment in good process and documentation, we used to make a lot of repeat mistakes.  It drove me nuts.  One careless mistake by a smart person cost us about $75K.  The harder I tried to stop these, the more frustrated the staff would get.  The psychic load would offset the process wins.  Plus, we'd invest more process only to trade one set of problems for another and have little gain to show for the investment.  Sound familiar?  No one likes this, yet we do it all the time!</p>"},{"location":"hardware/beginners/kaizen/#saved-by-the-new-york-review-of-books","title":"Saved by the New York Review of Books","text":"<p>Often, late at night, I vacuum up the Internet on the hunt for cool ideas that I can apply to innovation of all sorts: product, process and people.  One night last year, right after we started ZeroDiff, I ran across this Tim Park essay in the New York Review of Books: </p> <p>http://www.nybooks.com/blogs/nyrblog/2014/dec/03/weapon-for-readers/ </p> <p>This sentence from Tim's essay hit me like lightning:</p> <p>A pen is not a magic wand. The critical faculty is not conjured from nothing. But it was remarkable how many students improved their performance with this simple stratagem. There is something predatory, cruel even, about a pen suspended over a text. Like a hawk over a field, it is on the lookout for something vulnerable.</p> <p>Wow. That one paragraph changed our company!</p> <p></p>"},{"location":"hardware/beginners/kaizen/#read-with-a-pen","title":"Read with a pen","text":"<p>After this article I added a simple instruction to Step 0 of all our process documents:</p> <p>Print this page and make sure it follows the device through the development cycle.</p> <p>I also request that development cycle leaders handwrite their name at the top and always carry the document with them while they work.  I ask that they have a red pen handy at all times and freely make notes as they go.  These notes can be reminders, edits, additions, removals, or simply complaints to me about stupid stuff.</p> <p>A cool side effect of this change is that we iterate our process like crazy now because individuals capture high-quality detail in the moment, and then edit the online process docs repo from those notes later.  And we do this without meetings.  Yay!  The process changes so fast that we run the development cycles from the printed document that was live when the cycle started.</p> <p>Today I end almost every staff meeting with: \"OK, folks, and let's not forget: 'Read with a pen!'\"  These process docs come back to me when a development cycle completes.  I don't check them in detail - it's really more for me to watch the cadence of this process to ensure that everyone is still onboard.</p>"},{"location":"hardware/beginners/kaizen/#ditch-the-retrospectives-to-be-really-agile","title":"Ditch the retrospectives to be really agile","text":"<p>Sure, retrospectives are the de rigueur of agile software development today, but how much do people really remember about what they did last week?  Memory is a fuzzy thing and people tend to remember things emotionally rather than logically.  And do you really want another meeting at all, let alone one where folks with the strongest emotions tend to steer the retrospective?</p> <p>Now that I've seen it, I know the most important process changes are mundane, complex and nuanced - exactly the unemotional detail bits we fail to commit to memory.  We stopped our retrospectives because at the end of a process the red-pen markups are the process changes!  One person simply commits them straight to Confluence.</p>"},{"location":"hardware/beginners/kaizen/#pens-are-a-powerful-kaizen-tool-who-knew","title":"Pens are a powerful Kaizen tool, who knew?","text":"<p>So I got rid of \"yet another pointless meeting\" and I rooted out all of those frustrating silly mistakes that only smart people make.  As each member of the staff works today they capture those details we often forget, and we easily commit them to the process repo later.  Everyone benefits from these detailed knowledge captures.  </p> <p>Today, we mostly make \"interesting\" mistakes - the type that arise from the novel challenges engineers were built to solve.</p>"},{"location":"hardware/beginners/overview/","title":"Overview","text":""},{"location":"hardware/beginners/overview/#getting-started","title":"Getting Started","text":"<p>The documents in the \"beginner\" section are meant to help you bootstrap the right culture from the get-go. A modest investment now will help you grow into the right processes as you need them. You'll also lay the groundwork for a world-class org without adding much overhead.</p>"},{"location":"hardware/beginners/overview/#too-much-process-the-only-thing-worse-than-no-process","title":"Too Much Process: the Only Thing Worse than No Process","text":"<p>Everything about an emergent hardware startup is nuts. Of course we want coordinated, two-week dev sprints, test-driven development systems, formal design, production-revision control, CMS release process, signed firmware binaries built from CI, test/burn-in jigs, BOM management, build planning and parts/inventory control!</p> <p>But who the hell is going to do all this work? We have a house-on-fire problem with the current design. We're still pre-PMF and the founders don't agree on how to navigate out of it. Money (lack of it) is a constant stressor. No one is sleeping enough. Every week, and sometimes every day, seems like a heroic struggle just to get the damned demo to work, or to engage people in the idea. And despite tons of great feedback, not a single person has actually paid us anything for our great idea.</p> <p>And this is how it should be! You have one goal only: get something working enough so that someone will pay you for it before you run out of money.  Until you have a live PoC and relatively clear concept validation, no one on the microbus should ever work on: \"going pro,\" \"cms-ready,\" \"big reveal,\" \"costed-BOM,\" \"opening experience,\" or anything even remotely related to \"production operations.\"</p>"},{"location":"hardware/beginners/overview/#adopt-cpi-as-your-garage-culture-youll-build-a-world-class-org","title":"Adopt CPI as your Garage Culture - You'll Build a World-Class Org","text":"<p>We see a middle ground between \"going pro\" and \"trainwreck city.\" Start with a kernel of continuous process improvement, and you'll capture the hard-won lessons as you go and only invest in process where you actually need it. Moreover, CPI/Kaizen is the hallmark of a great organization whether your sales are $1 or $100B.</p> <p>It requires a little bit of setup and some leadership discipline, but the small investment is worth it as it will save a huge amount of time and heartache in the long-run. It will also help you grow a world class organization that produces stable, reliable products. No matter how big you get, your product will never be done, your team will never be perfect, and your process will always contain execution risks. CPI/Kaizen puts striving to improve at the center of your culture, and from that you organically capture the hard-won lessons as you learn them. And you'll build a culture that forever wants to be a little more efficient, reliable, delightful, robust and better. The incumbents in your space will generally be the opposite, and the fact that your org can delight when the incumbents cannot will be a powerful competitive edge. </p> <p>So if your startup hasn't formalized a process, and you think of yourself as someday \"going pro\" then start with the following list, and you will find that you can grow into everything that you need:</p>"},{"location":"hardware/beginners/tdd_ci/","title":"TDD/CI","text":""},{"location":"hardware/beginners/tdd_ci/#continuous-integration","title":"Continuous Integration","text":"<p>Use TeamCity. The end. (Seriously.)</p>"},{"location":"hardware/beginners/tdd_ci/#teamcity-on-aws","title":"TeamCity on AWS","text":"<p>The cool thing about TeamCity is that it can do high-quality CI for just about everything there ever was: desktop app, native mobile, webapp, backend, firmware and yes, automated monkey tests for hardware. Even if you already use an outsource CI solution for the backend or web, you'll be much more effective if you adopt a tool like TC that can literally build just about any weird thing that's scriptable on Linux, Windows or Mac instances. Spinning up an instance of TC on AWS is nearly plug-and-play. This also allows you to set it up to spin up buiild workers as needed to deal with load.</p> <p>https://confluence.jetbrains.com/display/TCD9/Setting+Up+TeamCity+for+Amazon+EC2</p>"},{"location":"hardware/beginners/tdd_ci/#tdd","title":"TDD","text":"<p>It's hard to know what firmware, RTOS, builder platform, etc. that anyone will use for their hardware target. Our experience is largely with C/C++ and support for unit testing with CUnit is pretty good. Combined that with an IDE that supports CUnit (all the Eclipse variants) and you can have your firmware developers follow the red-green-refactor TDD process. </p>"},{"location":"hardware/beginners/tdd_ci/#end-to-end-testing","title":"End-to-end Testing","text":"<p>There's really not much point to E2E testing unless you do it on live hardware. Likely your build chain and deploy process is pretty messy and not automated to hardware. THIS IS OK. Your job as a beginner is to focus on user value. Just make good recipe documents for your build-deploy-test cycle. Maintain them via Kaizen like all of your processes! If your product is hit, you can always turn those good process recipes into automated monkey tests later.</p>"},{"location":"hardware/beginners/tdd_ci/#wait-did-you-say-no-automated-toolchain-deploy-to-hardware-jig-tests","title":"Wait, Did You Say, \"No automated toolchain-deploy to hardware jig tests?!\"","text":"<p>Yes! Invest nearly all of your time in design, user testing and ethnographic/market study. Don't invest a lot in automation (yet). If your product is so desirable that users complain about the occasional regression, then you're in good shape! If your product is perfection-on-a-stick, but undesirable, then you're sunk. (That's a clear sign you're still pre-PMF.) The first case is likely easily fixed, and it doesn't matter if you burn through a few users - the evidence says there will be tons more. In the second case, that's not easy to fix! Maybe it's even impossible to fix.</p>"},{"location":"hardware/beginners/user_docs/","title":"User Docs","text":""},{"location":"hardware/beginners/user_docs/#mkdocs-github","title":"mkdocs + github","text":"<p>Of course you can use any documentation system. We started with Confluence Wiki, but quickly discovered that made extra-organization cooperation hard. After a few years we moved all of our docs to mkdocs hosted on github. This makes the repo forkable, editable and shareable by your entire staff without the need to manage a separate wiki system. While not strictly necessary, you can just fork the ZeroDiff docs repo as your starting point.</p>"},{"location":"hardware/beginners/user_docs/#bootstrapping-from-zerodiff","title":"Bootstrapping from ZeroDiff","text":"<p>Probably the easiest thing to do is to fork this doc repo and have your team focus on the recipes in the beginner section. Once you start your Kaizen, you'll want to collect your process recipe changes in your own section. (Right now there's no clear way to do this - later we'll invest some redesign effort into a good way for orgs to share ZeroDiff while having a way to maintain their unique process recipes.)</p>"},{"location":"hardware/beginners/user_docs/#your-supply-chain-team-will-need-to-learn-github-anyway","title":"Your supply chain team will need to learn github anyway","text":"<p>Github is the right tool for shared, versioned work across the entire org. Even for docs. It might seem harder for non-engineers to use github, but the reality is that they'll need to use it anyway. The github app makes it pretty easy for novices to quickly pick up the right habits. There's a few things the app can't do (tags! grrrr...), and for that the website is pretty good!</p>"},{"location":"hardware/beginners/user_docs/#mkdocs-instructions","title":"Mkdocs Instructions","text":"<p>Over in the \"Contribute\" section, there's some docs on how to use and modify the mkdocs repo.</p> <p>Mkdocs instructions</p>"},{"location":"hardware/design/empathy/","title":"User Empathy","text":"<p>All design, to some extent, involves relativism. A breast cancer screening center in a typical hospital complex might use a typical clinic design to maximizes patient privacy and treatment efficiency. Unlike other clinics, these practices perform stressful and painful examinations of more than half the adult population. A designer who empathizes with users in this setting might employ a different design: curved walls, subdued lighting, medium tonal colors, waterfalls, generous robes, coffee and peaceful quietude (i.e. not forced to listen to someone else's music). Such a clinic exists, and the experience of that clinic is radically different.</p> <p>Notice we make no call to prescriptive design policy - instead we believe it's valuable, perhaps essential, to understand relativism when you set out to empathize with your users. An opinionated point of view is good, but that needs to come from the culture and humans who will occupy the design.</p>"},{"location":"hardware/design/empathy/#mid-century-designers","title":"Mid-Century Designers","text":"<p>Because ZeroDiff is about low-volume production, a better analogy for these designs originate in architecture. Sure, Dieter Rams produces glorious products, but these are mass market objects offered on a take-it-or-leave-it basis. A large corporation will produce dozens or more objects per year, only a handful end up at mass-scale, and even then there are hits and misses.</p> <p>The great Mid-Century designers like Richard Neutra, Mary Colter, and Eliot Noyes would spend considerable time with the site and the client in order to understand how they might occupy a space. Richard Neutra worked directly with end users for all his projects no matter how small.</p> <p>I am an eyewitness to the ways in which people relate to themselves and to each other, and my work is a way of scooping and ladling that experience.</p> <p>Richard Neutra</p> <p>This quote is beautiful because he generously allows the design to originate from the end users rather than a design \"school of thought.\" One could argue that certain design thoughts represent a timelessness that stands apart from the end users, but even Bauhaus, as taught by Bruno Taut, embraced Humane Functionalism. </p>"},{"location":"hardware/design/essential_user_task/","title":"First Principles","text":"<p>\u201cI think it is important to reason from first principles rather than by analogy. The normal way we conduct our lives is we reason by analogy. [When reasoning by analogy] we are doing this because it\u2019s like something else that was done or it is like what other people are doing \u2014 slight iterations on a theme.</p> <p>First principles is kind of a physics way of looking at the world. You boil things down to the most fundamental truths and say, \u201cWhat are we sure is true?\u201d \u2026 and then reason up from there.</p> <p>Elon Musk</p> <p>In design, the first principles are the irreducible essence of a user's task or goal. It is not about the steps or the artifacts, but the user goal state. Usually, these will be short statements that seem somewhat obvious. If you cannot reduce a user task to first principles, then likely you don't understand the task.</p>"},{"location":"hardware/design/essential_user_task/#essential-user-task","title":"Essential User Task","text":"<p>An essential user tasks tends to be simple (maybe even obvious), foundational and irreducible. </p> <p>The first step to good design is to understand what the user needs to accomplish and why. Our favorite example is the programmable thermostat: for decades thermostats accreted features and behaviors: setpoints, programmability, connectedness, memory, battery backup and so on, but the user experience of them remained awful. In 2010 NestLabs deduced that the original designs all failed to grasp the essential user task: maintain situation-aware comfort when the user is at home, and to save power at all other times. Given this simple, clear essential user task, it becomes painfully obvious that features like setpoints and programs were artifacts the designers imposed on the user that did not directly address the user's core need.</p>"},{"location":"hardware/design/essential_user_task/#example-essential-user-tasks","title":"Example essential user tasks:","text":"<p>I need to prepare to host 20 people at a backyard BBQ Saturday.</p> <p>I need to launch 5,000 kilos into low Earth orbit.</p> <p>This may seem simplistic, but when you pare back the goal to its irreducible version, you can see how anything the designer adds is really an artifact, and not the goal itself. Artifacts are the choices that service the goal. For a BBQ there are many questions and artifact that derive from the essential user task: Supplies? Instacart? Whole Foods? BevMo? Prep? Furniture? RSVPs? As user and design stories build, it should be possible to validate that each one directly services the essential user task. You can cut everything else.</p> <p>It's important not to confuse these artifacts with the essential user task itself. The approach to addressing the essential user task will be different among designers, and that will result in a different set of artifacts, but each set, if it really services the essential task, should render a praiseworthy solution.</p>"},{"location":"hardware/design/ethno_study/","title":"Ethnographic Study","text":"<p>The best way to understand users is to meet them in their native environment and observe how they behave and interact. The goal for a good designer should be  to capture qualitative data about the users at the site. When you understand the users' culture and pair that with the essential user task, you end up with a deeper understanding of how they inhabit their work.</p> <p>A good ethnographic study will have the following characteristics:</p> <ul> <li>It takes place in the field where the users work</li> <li>The primary data collection method is observation</li> <li>The research team should interview users to clarify observations</li> <li>The research team should capture artifacts, including the context of their use</li> </ul> <p>The final product should be a narrative report that includes observations, interviews, photos/videos and artifacts - all organized in a way reveals the qualitative nature of the site and users.</p> <p>Wikipedia provides a good starting point for ideas about how and why to conduct an ethnographic study: Ethnographic Study Features</p> <p>An excerpt of that article includes the follow guidelines:</p> <ul> <li>Involves investigation of very few cases, maybe just one case, in detail.</li> <li>Often involves working with primarily unconstructed data. This data had not been coded at the point of data collection in terms of a closed set of analytic categories.</li> <li>Emphasises on exploring social phenomena rather than testing hypotheses.</li> <li>Data analysis involves interpretation of the functions and meanings of human actions. The product of this is mainly verbal explanations, where statistical analysis and quantification play a subordinate role.</li> <li>Methodological discussions focus more on questions about how to report findings in the field than on methods of data collection and interpretation.</li> <li>Ethnographies focus on describing the culture of a group in very detailed and complex manner. The ethnography can be of the entire group or a subpart of it.</li> <li>It involves engaging in extensive field work where data collection is mainly by interviews, symbols, artefacts, observations, and many other sources of data.</li> <li>The researcher in ethnography type of research, looks for patterns of the groups mental activities, that is their ideas and beliefs expressed through language or other activities, and how they behave in their groups as expressed through their actions that the researcher observed.</li> </ul>"},{"location":"hardware/design/fewer/","title":"Make fewer things that are more valuable","text":"<p>Good design is good business.</p> <p>Eliot Noyes</p> <p>A good, iterative design process will identify early which objects have \"pull\" and which do not. It's important to kill mediocre or bad product before it gets far into the process. Invest instead in making just a few objects that are great. The only way to learn this stuff early is to iterate rapidly and measure, measure, measure. ZeroDiff and a good design methodology allows you to run these tests quickly. It's true that some mediocre product concepts might flip to great because small design changes can have chaotic impacts on product value. As a small organization you do not have the luxury to chase these leprechauns. It's wiser to focus on the products that demonstrate excellence early in the process.</p>"},{"location":"hardware/design/sprint/","title":"Design Sprints","text":"<p>Probably the Gold Standard for design sprints is Ideo's Design Kit: The Field Guide to Human-Centered Design. The problem is that these are large, complex beasts and small companies generally won't have the resources to conduct them. (If you do, then go for it!)</p>"},{"location":"hardware/design/sprint/#google-ventures-design-sprint-gvds","title":"Google Ventures Design Sprint (GVDS)","text":"<p>A derivative of this process is the Google Ventures Design Sprint. This process follows a five-day arc led by a designer/facilitator and commanded by a product owner.</p> Stage Activity Theme Pre-Sprint Set the stage Prep Monday Create a framework for the sprint Understand Tuesday Summarize existing solutions, sketch new solutions Diverge Wednesday Critique new solutions, narrow the focus, storyboard one Converge Thursday: Create a works-like/looks-like prototype (Keynote, sketches, foam, paper, etc.) Prototype Friday Test the prototype with real users. Test &amp; Learn <p>The good thing about the GVDS process is that it's not democratic. The product owner ultimately makes the call on decisions, and that's good because it tends to focus the effort on fewer ideas of better quality.</p>"},{"location":"hardware/design/sprint/#everyday-sprints","title":"Everyday Sprints","text":"<p>For a small company it might be hard to find the resources entire teams to regularly spend a week to run GVDS process. Since there will be tons of continuous design choices along the entire product gradient, you want to make sure the most important decisions come from a careful, measured process. For this reason we invented the \"Everyday Sprint\" that teams could run regularly with low burden. Typically we follow these steps:</p> <ul> <li>Choose one or two central tasks that need design thought.</li> <li>One or more people conduct an ethnographic study with these central questions in mind (a half-day usually).</li> <li>The sprint leader selects members to join the design sprint, and shares the \"cooked\" study data and schedules 60-90 minutes to run the sprint.</li> <li>The day before, the sprint leader secures materials for the sprint (stickies, pencils, erasers, timers, and the room).</li> <li>Just before the sprint, the leader preps the room:<ul> <li>Write the essential user task on the whiteboard.</li> <li>Write the 1-2 design sprint central questions.</li> <li>Partition the board into three design story classifications columns: essential, uncertain and ideal.</li> <li>Sharpens all the pencils, arranges the materials and chooses the teams.</li> </ul> </li> <li>Working in teams of 2-3 people, you allow 30 minutes for each team to rapidly and simultaneously create design stories that address the selected central question on the board.</li> <li>At the end of 30 minutes the teams work together to read their stories aloud and the group votes if the story is \"essential, uncertain or ideal.\"</li> <li>The sprint leader sticks the voted stories in the correct column, allowing for (near) duplicates by stacking the duplicates.</li> <li>Repeat this process for all the central questions on the board (generally you do not want more than two).</li> </ul> <p>At the end of the design sprint, the sprint leader and product (or feature) owner should have a complete set of design stories categorized by how essential they are to the user process under consideration. These stories get entered into the tracking system (e.g. Jira) for the development team to slot into developer sprints. Because you've taught the development team good design practices, it's both safe and rewarding to allow them to run development from the design stories alone. (Most developer teams will likely first generate user stories and detailed specifications from the design stories.) The good thing about this process is that it's not prescriptive - design stories states what's needful and gives the developer wide intellectual latitude to come up with the best solution.</p>"},{"location":"hardware/design/teach/","title":"Teach, Don't Lead","text":"<p>Design happens at all levels of the product development process. Great designers realize they make a bigger impact when they teach the entire organization good design methodology. </p> <p>Our experience is that developer team uptake for design methodology is uneven. Often the resistant teams don't understand the design process value because it seems simplistic or superfluous to coding and construction. Teams like this typically feel more comfortable banging out user stories or specifications. While true they can make the code match these stores well, perhaps in pleasing ways, the resulting work may not address need, or misses that \"a-ha\" experience where you understand at an entirely different level. These teams are almost never hostile about this, so you can get them to begrudgingly change their methodology \"this one time.\" They might complain about it before and during, but often they'll look back and think, \"Wow, we would never have gotten here in the traditional methodology.\" That doesn't mean you won't have to drag them kicking and scratching into more design sprints, but they will come to respect and appreciate the results.</p> <p>Another concern is that some teams may have legitimate, long spells between design sessions. The designer will need to step in and refresh the team, but it should be a gentle shadow during the sprint. The team really needs to own the sprint. </p> <p>A designer who gets the entire organization to adopt sound design methodology is now free to orchestrate a larger, cohesive vision.</p>"},{"location":"hardware/design/testable/","title":"What's Testable?","text":"<p>When you start a new design, first look at your design stories to figure out what's testable about the design. Record this in a list that you can review during the test creation process. Not everything you want to test derives from the stories - often we know to perform tests based on experience. Add these \"expert\" tests to the list as well. As you design the object and create the manufacturing artifacts, you should verify that you accommodated each test from your starting list</p>"},{"location":"hardware/design/testable/#automated-monkey-testing-amt","title":"Automated Monkey Testing (AMT)","text":"<p>We discuss AMT elsewhere, but generally, design changes can have unintended consequences that you might not be easy to spot in any one design revision. We once had a situation where one of our EEs accidentally changed the net type for differentially driven bus (RS485). Each individual device tested OK, but when put into a chain close to the rated communication speed and bus length, the devices began to glitch. This test wasn't in our AMT at the time, so unfortunately the device went to the CMS for first articles before we discovered the problem. The goal is to use AMT to test your devices as close to Real World as possible.</p> <p>The goal should be to capture as many of these tests in automated processes as possible.</p>"},{"location":"hardware/design/testable/#ideas-for-testing","title":"Ideas for Testing","text":"<p>The following lists should jog your memory of the types of things you should test. </p> <p>(Likely the your complete list will be longer than this.)</p>"},{"location":"hardware/design/testable/#ee","title":"EE","text":"<p>The kinds of things that are testable in any EE design might include:</p> <ul> <li>Input Power Range</li> <li>Input Power Transients</li> <li>Output Power Load</li> <li>Current Draw in All Modes: Active, Standby, Sleep</li> <li>Battery Life, Charge Cycles/Performance</li> <li>SMPS Output Side DC Voltage Ripple</li> <li>SMPS Performance around Extreme Power Conditions (Input, Load, Transients, Battery, etc.)</li> <li>Ground Loops, Faults</li> <li>Data Bus Integrity, Stability, Impedance Match (I2C, SPI, UART, RS485, GPIO)</li> <li>I/O Ports Ground Isolation Protection (Body Diode, Etc. As Needed)</li> <li>I/O Port Mechanical Strength (Bosses as needed</li> <li>Firmware Storage Banks, Special Values</li> <li>Immutable Flash Parameters</li> <li>Clocks (Crystals, Oscillators, Derived Clocks, Bus Clocks)</li> <li>Switches, Buttons</li> <li>IR/Proximity Sensors</li> <li>EM Noise Generation (Incl Harmonics)</li> <li>Displays, Indicator LEDs</li> <li>RF Sensitivity (@ Nominal Freq), Stability, Radiated Power</li> <li>Regulatory Certifications (UL, CE, FCC/IC)</li> </ul>"},{"location":"hardware/design/testable/#mechanicals","title":"Mechanicals","text":"<ul> <li>Material Durability</li> <li>Machined, Molded, Printed Parts Durability</li> <li>Connector Protections (Strength, Strain Relief, Bend Radii)</li> <li>Display Durability (Scratch/Break Avoidance Measures/Resistance)</li> <li>IP rating (Dust, Moisture, Water, Cold, Heat)</li> <li>Assembled Device Strength (Drop, Rubber Mallet, and Penetration Tests)</li> <li>Mount Strength Test</li> <li>Cycles Survivability (Levers, Switches, Buttons, Knobs, Rotating Parts, Doors, Touch Sensors)</li> </ul>"},{"location":"hardware/design/testable/#user-experience","title":"User Experience","text":"<ul> <li>Display Readability</li> <li>RF Performance (WiFi, BTLE, 802.15.4)</li> <li>Look, Fit, and Finish</li> <li>Resistance oo, or Acceptance of, Marring, Wear or Blemishes</li> <li>On-boarding</li> <li>Reset or Recovery from Weird Modalities</li> <li>Satisfies Design Stories</li> <li>Partial or Complete Solution to Essential User Task</li> </ul>"},{"location":"hardware/firmware/checklist/","title":"Firmware Checklist","text":""},{"location":"hardware/firmware/checklist/#ack-not-yet-ported-from-confluence","title":"Ack! Not yet ported from Confluence!","text":""},{"location":"hardware/hardware/mech_eng/","title":"MechE Dev","text":""},{"location":"hardware/hardware/mech_eng/#step-0-kick-off-development-cycle","title":"Step 0: Kick-off Development Cycle","text":"<p>The kick-off is essential to inform everyone that the object is now in-flight for another development cycle.  The steps for kick-off are:</p> <ul> <li>Send an announce email to rnd@codeshelf.com</li> <li>Schedule Kick-off meeting</li> <li>Ensure that the Current and Planned Hardware Releases page in the ZeroDiff Process Home page is accurate for the device (and any related projects or sub-assemblies) at every step of this process document. </li> <li>Print this page and make sure it follows the device through the development cycle.</li> <li>Always document while working, and always work with a pen.</li> </ul> <p>For information about how an object is designed, reference In Action Product Design Process. </p> <p>For information regarding Testing Criteria, reference Basic Hardware Testing Criteria.</p>"},{"location":"hardware/hardware/mech_eng/#step-1-create-design-artifacts","title":"Step 1: Create Design Artifacts","text":"<p>The first step of the design and manufacture of mechanicals is to create all of the relevant design and production artifacts (files).</p> <p>We are currently using Solidworks, Rhino, or Illustrator to design Mechanicals. Production documentation (drawings) is executed in Solidworks and output as PDF. Derivative CAD format files (those sent to vendors) are SLDPRT, STEP or EPS, depending on manufacturing process.</p> <ul> <li>Upload relevant Solidworks files to GrabCAD</li> <li>Be sure that the Solidworks files stay synced to GrabCAD in order to preserve change history</li> </ul>"},{"location":"hardware/hardware/mech_eng/#step-2-create-a-prototype-designer-protomgr","title":"Step 2: Create a Prototype (Designer, ProtoMgr)","text":"<p>To validate the design we produce an in-house prototype when possible.  This is a somewhat lightweight process and is not a tagged GitHub release, because there may be many of them.  </p> <ul> <li>If no prior Github repository exists for the project in question, file a JIRA Service Request with DevOps and request one with the appropriate project name.</li> <li>The engineer commits the CAD derivative files and PDF drawings to GitHub.</li> <li> <p>If the assembly requires a BOM the engineer creates a prototype BOM and mails it to the prototype shop manager.</p> </li> <li> <p>Hand off the document package to the Prototype Shop.</p> <ul> <li>The prototype shop manager schedules the build and coordinates with the production manager to acquire any missing BOM components.</li> <li>The prototype shop converts the STEP or SLDPRT file into gcode using the HSMWorks plugin for Solidworks.</li> <li>The prototype shop makes the parts.</li> <li>The prototype shop assembles the housing and delivers it to the HWTE. In the absence of the HWTE, prototypes are delivered to the design engineer.</li> </ul> </li> <li> <p>When mechanical devices cannot be prototyped in-house:</p> <ul> <li>Email production files to the ProdMgr along with requested turnaround time and quantities. </li> <li>ProdMgr will place RFQs and PO.</li> <li>Prototypes will be made at a CMS.</li> <li>Prototypes will be delivered to the HWTE. In the absence of the HWTE, prototypes are delivered to the design engineer.</li> </ul> </li> </ul>"},{"location":"hardware/hardware/mech_eng/#step-3-test-the-prototype-hwte-designer","title":"Step 3: Test the Prototype (HWTE, Designer)","text":"<ul> <li>The HWTE and design engineer create a complete template object (built to the design intent) to test against.</li> <li>The HWTE and design engineer run all of the relevant tests set out in the design process to validate that the prototype is correct. Refer to the Basic Hardware Testing Criteria google doc. </li> <li>The document should be printed and reviewed with a pen.</li> <li>If the HWTE approves the device for production then proceed to step 4, otherwise go back to step 1.</li> </ul> <p>Hand off the document package to the Designer.</p>"},{"location":"hardware/hardware/mech_eng/#step-4-create-release-candidate-rc-artifacts-designer","title":"Step 4: Create Release Candidate (RC) Artifacts (Designer)","text":"<p>For a mechanical/housing manufacturing run, the release package contains the following documents, as appropriate to the design and type of manufacturing process (in other words, not all designs will require each of the file types below).  The filenames derive from the base product ID, e.g. POSCON.XXXXXX  </p> <p>CNC Manufacturing typical file sets</p> File Example Prod/Design Folder Drawing POSCON.FACE.dxf Production Drawing POSCON.FACE.pdf Production Vector File POSCON.FACE.eps Production (if lasercut) Solidworks File POSCON.FACE.SLDPRT Production (if CNC) STEP file POSCON.FACE.STEP Production (if CNC) <p>Lasercutting File typical file set:</p> File Example Prod/Design Folder Drawing POSCON.FACE.pdf Production Vector File POSCON.FACE.dxf Production Vector File P2X142 POSCON.FACE.eps Production (if lasercut) README POSCON.FACE.README.docx Production (if lasercut): <p>Lasercut production file naming convention:</p> <ul> <li>SheetSize X Part yield per sheet PART.NAME.eps PRODUCTION</li> </ul> <p>3D Printed File typical file set:</p> File Example Prod/Design Folder Drawing POSCON.FACE.stl Production Drawing POSCON.FACE.pdf Production <p>Bill of Materials, Engineering Change Order file set:</p> File Example Prod/Design Folder BOM POSCON.MECH.BOM.xlsx Production ECO POSCON.FACE.eco.xlsx Production <p>A typical release package would include some combination of:</p> <ul> <li>DXF, AI or EPS Vector file for laser cut parts</li> <li>Specific production files for current vendor (eg - Ponoko laser cut layout and ReadMe file)</li> <li>Stereolithography File (STL)</li> <li>SLDPRT, STEP and/or IGES File</li> <li>PDF Drawing File</li> <li>Engineering Change Order (ECO)</li> <li>Bill Of Materials (BOM)</li> </ul> <p>Editing ECOs:</p> <p>If changing the design of a previously released object, best practice is to update and commit the ECO as the object is being designed.</p> <p>If working on a new production object, follow these steps:</p> <ul> <li>Open the New ECO Template (link here)</li> <li>The Commit Message field for a new production object should read \"Initial Commit, v1.0\" for a new project.</li> <li>Create a column in the ECO for each part being released by us to the right of the MISC Changes column in order to record future changes.</li> <li>Copy the Commit Message field in the ECO and paste it to the Commit Message field in Github before committing the ECO.</li> </ul> <p>If working on a previously released production object, follow these steps:</p> <ul> <li>Record changes to each part in its individual column.</li> <li>If adding a new part, add a column and name it \"Part_Name Changes\".</li> <li>If deleting a part, note that in the part's column. Do not delete the column.</li> <li>Copy the change messages into the Commit Message field in the ECO. If the message is \"none\", ignore it.</li> <li> <p>Copy the Commit Message field in the ECO and paste it to the Commit Message field in Github before committing the ECO.</p> </li> <li> <p>Print drawings</p> </li> <li>Highlight changes</li> <li>Examine the changes for errors and make any needed corrections</li> </ul> <p>These changes should also be reflected in the commit messages in Git.</p> <p>If there is a design change to any part in the assembly, the entire assembly needs to increment, but other drawings in the same assembly that are separate and not changed do not need to increment. Any levels above the re-versioned assembly will also need to increment. </p> <p>Ensure that drawings made for production (other than laser cutting) comply with ANSI Standards:</p> <ul> <li>Limit dimensions should be used on all individually dimensioned toleranced parts.</li> <li>The Baseline dimensioning system should be used to locate toleranced surfaces to avoid an accumulation of tolerance.</li> <li>All dimensions should be given in decimals except drill sizes, fillets and rounds, and standard fasteners.</li> <li>Each dimension should be given clearly so that it can be interpreted in only one way</li> <li>Dimensions should not be duplicated or the same information given in two different ways and no dimensions should be given except those needed to produce or inspect the part.</li> <li>Dimensions should be given to finished surfaces or important center lines, in preference to rough surfaces, whenever possible.</li> <li>Dimensions should be so given that it will not be necessary for the machinist to calculate, scale, or assume any dimension.</li> <li>Dimensions should be given in the view where the shape is best shown.</li> <li>Dimensions should be placed in the views where the features dimensioned are shown true shape.</li> <li>Dimensions should not be placed on a view unless it eliminates long extension lines and makes the dimension clearer.</li> <li>Dimensions applying to two adjacent views should be placed between the views if possible.</li> <li>The longer dimensions should be placed outside all intermediate dimensions so that dimension lines will not cross extension lines. </li> <li>Do not force workers to assume that a feature is centered. Provide a location dimension.</li> <li>Non-toleranced detail dimensions may be chained if necessary, or avoid a complete chain of detail dimensions by omitting one and providing an overall dimension. </li> <li>Dimension lines should be spaced uniformly (approximately \u215c\u201d apart).</li> </ul> <p>For a complete ANSI checklist, refer to ANSI Dimensioning Guidelines v1.1.</p>"},{"location":"hardware/hardware/mech_eng/#step-5-commit-the-release-candidate-package-to-github","title":"Step 5: Commit the Release Candidate Package to GitHub","text":"<p>When working with RC files, best practices dictate that all files being created, edited and committed to GitHub be managed from the same place to keep the workflow consistent.</p> <ul> <li>Commit the above files to GitHub.</li> <li>When doing so, observe that no \"lockfiles\" are entered into the repository when a commit is made. (These are created when saving XLS files with LibreOffice and look like *.xls#. Right-click on these in Github and choose the \"Ignore .XLS#\" Be sure you're using the ignore command on the correct file.  </li> <li>Diff the files in Github in order to determine which files have been changed</li> <li>Examine changed files for errors</li> <li>Correct any errors found</li> <li>Tag the commit ID as a Release Candidate (RC).  E.g. V1.1-RC1</li> <li>Descriptions of changes that have been committed need to be included in the commit message.</li> <li>Copy commit messages between the RC release and the final production release into the ECO.</li> <li>The RC tag should increment (RC1, RC2) until the object is approved for production and released with the appropriate production version tag (E.g. V1.1).</li> </ul>"},{"location":"hardware/hardware/mech_eng/#step-6-release-checklist","title":"Step 6: Release Checklist","text":"<ul> <li>Download and print all files in the RC package from GitHub. </li> <li>All files in the RC package must be checked against a printed Checklist: Mechanical Production Review v1.4. The document should be printed and reviewed with a pen.</li> <li>Any drawings to be released to CMs must be checked by the HTWE or in-house ANSI domain expert.</li> <li>If changes need to be made, go back to Step 4.</li> </ul>"},{"location":"hardware/hardware/mech_eng/#step-7-build-rc-articles-prodmgr-hwte","title":"Step 7: Build RC Articles (ProdMgr &amp; HWTE)","text":"<p>Once a part releases as RC, we send the release package to the CMS for a request to quote for manufacture.   RC articles are not needed if the same outside CM has manufactured the prototype, and the same design has been approved for production with no changes. If either the design or manufacturing process changes from the approved prototype, RC articles are needed. </p> <ul> <li>Email the ProdMgr to request an RC build along with requested turnaround time and quantity. </li> </ul> <p>Hand off the document package to the Production Manager.</p> <ul> <li>ProdMgr will place RFQs and PO.</li> <li>RC articles will be made at a CMS.</li> </ul> <p>The CMS is not allowed to make any changes to this package without first looping back to Codeshelf to obtain an approved ECO.  If we receive an ECR from the CMS, we review it and decide if we will approve the change.  If we agree to approve the change, then we capture that change in the appropriate documents (BOM, ECO, etc.) and re-release the product with these changes, incrementing the tag. </p> <p>Hand off the document package to the Hardware Test Engineer when RC Articles are complete and delivered.</p> <ul> <li>RC articles will be delivered to the HWTE. In the absence of the HWTE, RC articles are delivered to the design engineer.</li> <li>When the device comes back from the CMS, it gets assembled by the prototype shop (if not already assembled by the outside CMS).</li> <li>ProdMgr checks whether CMS has made any modifications to the design. If so, the design needs to be revised and re-versioned. </li> </ul>"},{"location":"hardware/hardware/mech_eng/#step-8-test-and-validate-rc-articles-hwte-designer","title":"Step 8: Test and Validate RC Articles (HWTE &amp; Designer)","text":"<p>RC articles must be approved by the HWTE / designer in order to release for production. </p> <p>Hand off the document package to the Hardware Test Engineer.</p> <ul> <li>Print the Basic Hardware Testing Criteria and review with a pen.</li> <li>Run all of the relevant tests set out in the design process to validate that the article is correct.</li> </ul> <p>If the HWTE approves the device for production then proceed to step 9, otherwise go back to step 4. Step 9: Release Tag (Designer)</p> <p>Hand off the document package to the designer/engineer.</p> <p>When RC articles are proven good and approved for production:</p> <ul> <li>Tag the final commit with with the appropriate production version number. </li> </ul> <p>Github automatically notifies ProdMgr of the release. </p> <p>Hand off the document package to the Production Manager.</p>"},{"location":"hardware/hardware/mech_eng/#step-10-release-announcement-prodmgr","title":"Step 10: Release Announcement (ProdMgr)","text":"<pre><code>Issue a release announcement\nUpdate the Current and Planned Hardware Releases and Products in need of release documents.\n</code></pre> <p>The item is then cleared for ongoing production.</p>"},{"location":"hardware/hardware/mech_eng/#step-11-post-release-review-prodmgr","title":"Step 11: Post Release Review (ProdMgr)","text":"<ul> <li>Review the release process with the Engineer</li> <li>Change the release process document as needed</li> <li>Change the release checklists as needed</li> </ul>"},{"location":"hardware/hardware/mech_eng_test/","title":"Test Criteria","text":""},{"location":"hardware/hardware/mech_eng_test/#design-test","title":"Design Test","text":"<ul> <li>Do screws back out?</li> <li>If special tools are needed, do we have enough of them? Torx, Allen, etc?</li> <li>During assembly</li> <li>Does it feel solid?</li> <li>If there are points of weakness, where are they?</li> <li>Anything obviously wrong should be noted</li> <li>Do the buttons actuate? Anything interfering with them?</li> <li>Static Electricity testing</li> <li>Electrical shorts through housing?</li> <li>Do cables fit securely?</li> <li>Do they break contact?</li> <li>Does the housing interfere with cable connections?</li> <li>Squeeze the device and look for any changes in behavior or fit/finish</li> <li>Shake the device, listen for loose PCB or other parts</li> <li>If the device has mounting affordances, mount it</li> <li>How much force is required to remove it?</li> <li>How much force is needed to mount it?</li> <li>Can it be twisted off of the mounting surface/area?</li> <li>How do finishes hold up with abrasion?</li> <li>Is the device easily cleanable?</li> <li>Fingerprints?</li> <li>Do housing components assemble/align well?</li> <li>Has intended design symmetry been preserved?</li> <li>Are corners broken? Any obvious burrs?</li> <li>Are fillets present?</li> <li>Holes in housing for connectors</li> <li>What is the appropriate torque application for screws? Are electric screwdrivers not advised?</li> </ul>"},{"location":"hardware/hardware/mech_eng_test/#cad-sanity-check","title":"CAD Sanity Check","text":""},{"location":"hardware/hardware/mech_eng_test/#prototyping","title":"Prototyping","text":"<ul> <li>Have we made sure that all parts are final production units and not holdovers from prototyping?</li> </ul>"},{"location":"hardware/hardware/mech_eng_test/#vendor-acceptanceqa","title":"Vendor Acceptance/QA","text":""},{"location":"hardware/hardware/mech_eng_test/#tolerances-and-standards","title":"Tolerances and Standards","text":"<ul> <li> <p>Measure Against Drawings, check against Codeshelf standard tolerances (on drawings)</p> <ul> <li>Thickness</li> <li>Height</li> <li>Length</li> <li>Width</li> </ul> </li> <li> <p>Finish Examination</p> <ul> <li>Any surface finish callouts on drawings should be checked against finished parts</li> <li>Note any obvious mechanical flaws on mating surfaces</li> <li>Note cracks, flaws or imperfections</li> <li>Corners rounded/broken? Check for sharp edges</li> <li>Look for mars, scratches</li> </ul> </li> <li> <p>Mechanical Fit and Alignment</p> <ul> <li>Test-fit mating parts and examine for alignment issues</li> </ul> </li> <li>Assembly Tests<ul> <li>Assemble fully</li> <li>Tighten screws</li> <li>Check for gaps in mating parts</li> <li>Housing ports/holes for connectors</li> <li>How close is the fit around the cable?</li> <li>Does the cable break contact?</li> </ul> </li> <li>Functional Tests<ul> <li>Buttons<ul> <li>Do buttons function as intended, mechanically?</li> <li>Are they aligned in their openings?</li> </ul> </li> </ul> </li> <li>Screens<ul> <li>Is the screen aligned with the edges of the housing?</li> <li>Are all pixels visible?</li> </ul> </li> <li>Antennae</li> <li>Screws/fasteners<ul> <li>Do screws back out?</li> <li>What happens when you overtighten them?</li> </ul> </li> <li>Endurance Tests<ul> <li>Drop Test</li> <li>Drop device from the height it is normally used from/mounted at</li> </ul> </li> <li>Shake Test<ul> <li>Vigorously shake the device and listen for rattles and other sounds, note them</li> </ul> </li> <li>Cable pull/Twist<ul> <li>Insert cables and pull them out. </li> <li>Note how much force is needed</li> <li>Note any breakage or loose parts</li> </ul> </li> <li>Squeeze Test<ul> <li>Squeeze the assembled device with your hands and look for gaps in the housing, note any sounds or breakage</li> </ul> </li> </ul>"},{"location":"hardware/hardware/mech_eng_test/#measurements-data-verifiedcollected","title":"Measurements Data Verified/Collected:","text":""},{"location":"hardware/hardware/mech_eng_test/#finish-notes","title":"Finish Notes","text":""},{"location":"hardware/hardware/mech_eng_test/#assembly-notes","title":"Assembly Notes","text":""},{"location":"hardware/hardware/mech_eng_test/#mechanical-tests-performed","title":"Mechanical Tests Performed","text":""},{"location":"hardware/hardware/meche_checklist/","title":"Release CheckList","text":""},{"location":"hardware/hardware/meche_checklist/#meche-release-checklist","title":"MechE Release Checklist","text":""},{"location":"hardware/hardware/meche_checklist/#check-that-all-files-are-included-in-github-pre-release-package","title":"Check that all files are included in GitHub pre-release package:","text":"<ul> <li>Does each part have its own folder named after it?</li> <li>Does each folder contain a drawing in PDF format, along with the appropriate derivative file (EPS, DXF, SLDPRT, STEP, etc.) format(s)? Refer to the tables in Step 4 of the 3. Mechanicals Development and Release Process if unsure.</li> <li>For lasercut parts, is there a README file containing the appropriate info on materials, thicknesses, sheet size, production file name, and any vendor specific information?</li> </ul>"},{"location":"hardware/hardware/meche_checklist/#download-the-pre-release-package-from-github","title":"Download the pre-release package from GitHub","text":""},{"location":"hardware/hardware/meche_checklist/#print-all-current-drawings-from-github-download","title":"Print all current drawings from GitHub download","text":"<ul> <li>If drawings have been revised, print previews. <ul> <li>Limit dimensions should be used on all individually dimensioned toleranced parts.</li> <li>Dimensions should not be duplicated or the same information given in two different ways and no dimensions should be given except those needed to produce or inspect the part.</li> <li>Dimensions should be given between points or surfaces that have a functional relation to each other or that control the location of mating parts.</li> <li>Dimensioning to hidden lines should be avoided whenever possible.</li> <li>Dimensions applying to two adjacent views should be placed between the views if possible.</li> <li>The longer dimensions should be placed outside all intermediate dimensions so that dimension lines will not cross extension lines.</li> </ul> </li> <li>Do drawings effectively communicate essential tolerance features?<ul> <li>Dimensions</li> <li>Materials</li> <li>Tolerances</li> <li>Review Version Numbers/Revision Numbers</li> </ul> </li> </ul>"},{"location":"hardware/hardware/meche_checklist/#review-bom-documents-from-github-download","title":"Review BOM Documents from GitHub download","text":"<ul> <li>Check that the BOM has the following data:<ul> <li>Is the project name showing in the BOM's header?</li> <li>Are all parts required to build the device represented?</li> <li>Are parts quantities correct?</li> <li>Are the dates current and correct?</li> <li>Are the manufacturer's part numbers present and correct?</li> <li>Are the Codeshelf part names present and correct?</li> <li>Are feedstocks and their associated dimensions present and correct?</li> </ul> </li> <li>Does the BOM contain all of the sourcing data needed to acquire the parts?</li> <li>Does the BOM contain feedstock and dimensions?</li> <li>Does each part have a name that follows the Codeshelf Part Number Scheme?</li> </ul>"},{"location":"hardware/hardware/meche_checklist/#review-eco-documents-from-github-download","title":"Review ECO Documents from GitHub download","text":"<ul> <li>Does the current version number\u2019s row in the spreadsheet describe all changes to this version/revision?</li> <li>Does the ECO reflect all design changes noted since the previous release and those noted in the commit messages?</li> </ul>"},{"location":"hardware/hardware/meche_checklist/#review-readme-files-found-in-production-files-folders-of-lasercut-parts-from-github-download","title":"Review README files (found in production files folders of lasercut parts) from GitHub download","text":"<ul> <li>Is the required material listed?</li> <li>Is the thickness of the material called out?</li> <li>Is all vendor-specific information listed (eg stock sizes, file names, sheet size, part yield, etc.)</li> </ul>"},{"location":"hardware/hardware/meche_checklist/#cross-check-drawingsbomeco-from-github-download","title":"Cross check Drawings/BOM/ECO from GitHub download","text":"<ul> <li>Do all instances of version numbers/revision letters agree?<ul> <li>Drawings (found in drawing title block)</li> <li>Do drawing / Part numbers and version numbers agree with the title blocks on the drawings?</li> </ul> </li> <li>BOM (Product Number, also in Drawing/Part No. fields)<ul> <li>Does the tag on the BOM agree with the release ID row on the ECO?</li> </ul> </li> </ul>"},{"location":"hardware/hardware/meche_checklist/#post-release","title":"POST-RELEASE:","text":"<ul> <li>Has the checklist been checked for necessary items/redundant items?</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/","title":"EE Checklist","text":""},{"location":"hardware/hardware/pcb_checklist/#pcb-release-checklist","title":"PCB Release Checklist","text":""},{"location":"hardware/hardware/pcb_checklist/#directory-setup","title":"Directory Setup","text":"<ul> <li>In Git: Select or create repo for a new design.</li> <li>In Eagle Control Panel (main window), add the repo or Git folder to \u201cProjects\u201d drop down</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#project-setup","title":"Project Setup","text":"<ul> <li>Within the \u201cProjects\u201d drop down of the Control Panel, select desired folder, right-click the folder and select \u201cNew Project\u201d. This will create a RED new project folder inside it which designates a project.</li> <li>Double-click the folder to enter into the project (denoted by a GREEN dot next to the folder when it is open) or double-click it again to close it (green light dot turns grey)</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#library-setup","title":"Library Setup","text":"<ul> <li>A set of common / past components is currently stored in the Git under \u201cArchive\u201d  -&gt; \u201cEagle Libraries\u201d -&gt; \u201cGW-devices\u201d; or in the Control Panel under \u201cLibraries\u201d -&gt; \u201cEagle Libraries\u201d. For KW2-specific parts, there is a library \u201cKW2\u201d in the same directory.</li> </ul> <p>NOTE: Library locations and content should probably be adjusted. Current common parts include a set of SMD resistors, capacitors, inductors, buttons, barrel jacks, several number displays and miscellaneous connectors.</p>"},{"location":"hardware/hardware/pcb_checklist/#schematic-creation","title":"Schematic creation","text":"<ul> <li>If not already open, double-click on Project folder or right-click -&gt; \u201cOpen\u201d in the Control Panel to open the project</li> <li>In Control Panel, \u201cFile\u201d -&gt; \u201cNew\u201d -&gt; \u201cSchematic\u201d or right-click on Project folder, then \u201cNew\u201d -&gt; \u201cSchematic\u201d. This opens a Schematic Editor window.</li> <li>Make sure board and schematic are consistent - ALWAYS have both layers open at the same time in Eagle!</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#library-creation","title":"Library creation","text":"<ul> <li>To create a new part, a schematic symbol (\u201csymbol\u201d), footprint (\u201cpackage\u201d) and association between the two (\u201cdevice\u201d) is required.</li> <li>In the top drop down (\u201cLibraries\u201d) of the Control Panel, navigate to or add your library.</li> <li>Double-click to open it, this will generate a new window.</li> <li>To create a schematic symbol, click the gate symbol in the menu bar. Select a current symbol to edit or create a new one. This will open a further new window where a symbol can be drawn.</li> <li>Draw &amp; place pins, rename pins by datasheet / function if desired</li> <li>To create a footprint, click the chip symbol in the menu bar. Select an existing or create a new footprint in the same manner as above.<ul> <li>Name pads by datasheet / function if desired</li> </ul> </li> <li> <p>To associate the symbol with the footprint, click the button with 4 gates in the menu bar. Either enter a new device name or select an existing one.</p> <ul> <li>Add schematic symbol via the gate button on the left menu panel (under the wrench button) and place it at the origin marker unless otherwise required.</li> <li>Attach a footprint by selecting the \u201cNew\u201d button at the bottom of the right panel.</li> <li>Click \u201cConnect\u201d in the same panel to associate footprint pads with symbol pins</li> <li>The part can now be used in schematic creation.</li> <li>Layout creation</li> </ul> </li> <li> <p>Once a schematic is completed, convert it to a layout. \u201cFile\u201d -&gt; \u201cSwitch to board\u201d (in Schematic Editor) will create a layout file with the same name in the project in the Layout Editor. If all symbols are part of a correctly created device, the footprints should all be added automatically.</p> </li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#layer-settings","title":"Layer settings","text":"<ul> <li>Click on the magnifying glass with wires in it (bottom most button on the right column of the left-side menu panel)</li> <li>Select the \u201cLayers\u201d tab and adjust as required. Note: Eagle by default numbers layers starting at 1 for the top layer and 16 for the bottom layer. A 2-layer board thus has top = 1 and bottom = 16, whereas a 4-layer has top = 1, inner1 = 2, inner2 = 15 and bottom = 16. NOTE: The example setup is incorrect; using it will result in a stackup numbered 1,2,3,16 which breaks various other features in Eagle. Ensure your setup is numbered correctly!</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#drc-settings","title":"DRC settings","text":"<ul> <li>In the same panel, adjust minimum feature size under \u201cSizes\u201d, trace / space / board edge clearances under \u201cClearance\u201d and minimum annular rings for vias and pads under \u201cRestring\u201d. Additionally, in \u201cMisc\u201d, check the \u201cCheck angle\u201d box for best results.</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#verify-a-design-in-eagle","title":"Verify a design in Eagle","text":"<ul> <li>DRC (Design review check) should have no warnings or errors.</li> <li>ERC check should have no warnings or errors.</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#exporting-a-design","title":"Exporting a design","text":"<ul> <li>CAM files accessed via the blue film-reel icon on the top menu or under \u201cFile\u201d -&gt; \u201cCAM Processor\u201d of the Layout Editor.</li> <li>Manufacturing files:<ul> <li>Gerber files (copper, silk, mask, stencil layers)</li> <li>Codeshelf has CAM files under \u201cArchive\u201d -&gt; \u201cCAM_ULP\u201d</li> <li>For each file, ensure the correct layers and features are checked. Defaults for copper are 1,2,15,16 for 4-layer boards and 1,16 for 2-layer. Adding the board outline to each file is not a bad idea either.</li> <li>For each file, ensure the output directory is correct. By default, the file will be created in the project directory. To change this, each file must be adjusted individually (!)</li> </ul> </li> <li>Drill file (holes)<ul> <li>Codeshelf does not have a CAM file for drills. Eagle provides one under \u201cCAM Jobs\u201d in the Control Panel (or under \u201ccam\u201d in the Eagle install directory)</li> </ul> </li> <li>Centroid</li> <li>BOM (from schematic)</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#create-a-new-library-part","title":"Create a New Library Part","text":""},{"location":"hardware/hardware/pcb_checklist/#new-library-part-review","title":"New Library Part Review","text":"<ul> <li>Schematic symbol corresponds to function / correct number of pins.</li> <li>Use a good naming scheme for the schematic pins.</li> <li>Pins on schematic match pins on package.</li> <li>Package geometric center is the part\u2019s centroid.</li> <li>Correct footprint is attached (e.g schematic and symbol have same number of pins).</li> <li>Footprint has pins in correct order (check layer for mirroring possibilities).</li> <li>Print 1.0 scale version and verify that the footprint matches the part and datasheet.</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#release-to-manufacturing-checklist","title":"Release to Manufacturing Checklist","text":""},{"location":"hardware/hardware/pcb_checklist/#schematic-review","title":"Schematic review:","text":"<ul> <li>All parts have assigned and CORRECT manufacturers and part numbers (check assigned datasheet vs symbol pin numbers, for instance)</li> <li>Pins on devices labelled as according to datasheets</li> <li>Nets named correctly (by function or pins)</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#layout-review","title":"Layout review","text":"<ul> <li>Fiducials for assembly (3 per side)</li> <li>Check net connectivity</li> <li>Make sure copper pours are present on all layers AND ACTUALLY POURED</li> <li>Check Reference Designators &amp; other labelling are on the correct silkscreen layers</li> <li>Check DRC for correct trace / space and minimum silk screen width according to manufacturer</li> <li>Correct version number applied (out of house do NOT include \u201cP\u201d suffix)</li> <li>All polarized components checked</li> <li>Check the orientation of all connectors</li> <li>Bypass capacitors located close to IC power pins</li> <li>PCB has power rail test points, and test points for important signals, all labeled and accessible</li> <li>Layout PCB so that any rework or repair of a component does not require removal of other components</li> <li>Mounting holes electrically isolated or not</li> <li>Proper mounting hole clearance for hardware</li> <li>SMD pad shapes checked</li> <li>Check for traces running under noisy or sensitive components</li> <li>No vias under metal-film resistors and similar poorly insulated parts</li> <li>Check for traces which may be susceptible to solder bridging if not masked (OFN pins etc)</li> <li>Check for dead-end traces, unless used on purpose</li> <li>Provide multiple vias for high current and/or low impedance traces</li> <li>Component and trace keepout areas observed</li> <li>Ground planes where possible</li> <li>Trace width sufficient for current carried</li> <li>No silkscreen legend text over vias (if vias not soldermasked) or holes</li> <li>All legend text reads in one or two directions</li> <li>Company logo in silkscreen legend</li> <li>Date code on PCB</li> <li>All silkscreen text located to be readable when the board is populated</li> <li>All ICs have pin one clearly marked, visible even when chip is installed<ul> <li>Ensure it is in silkscreen layer</li> </ul> </li> <li>CAD design rule checking must be turned on</li> <li>High frequency circuitry precautions observed</li> <li>Soldermask does or does not cover vias</li> <li>PCB thickness, material, copper weight noted</li> <li>Thermal reliefs for internal power layers</li> <li>Solder paste mask openings are proper size</li> <li>Blind and buried vias not allowed on multilayer PCB unless required</li> <li>Finished hole sizes are &gt;=10 mils larger than lead</li> <li>All capacitors have been designed with a 50 percent voltage margin.</li> <li>All new components/suppliers must be reviewed for component obsolescence and component availability</li> <li>All PCBA designs must have the revision level released to Document Control and assembly drawing indicating any special assembly/design requirements that violate the standard PCB assembly conventions (i.e. components on the solder side, cuts and jumps, heat-sink assemblies, etc.). - Open question for Calla / Nate</li> <li>All power traces wide enough for anticipated current</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#export-production-files","title":"Export Production Files","text":"<ul> <li>BOM<ul> <li>Check whether existing columns are: <ul> <li>Qty</li> <li>Value</li> <li>Package</li> <li>Parts/Reference Designator</li> <li>MFGN</li> <li>MFGP</li> <li>Notes</li> </ul> </li> <li>Gerbers<ul> <li>For each file, make sure the right features are selected as well as the board outline</li> </ul> </li> <li>Drill file<ul> <li>Visual inspection to see if holes line up</li> </ul> </li> <li>Centroid</li> </ul> </li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#review-gerber-files","title":"Review Gerber Files","text":"<ul> <li>Check to see if right files exists<ul> <li>Top silk</li> <li>Top mask</li> <li>Top paste</li> <li>Top copper</li> <li>Inner copper 1</li> <li>Inner copper 2</li> <li>Bottom copper</li> <li>Bottom paste</li> <li>Bottom mask</li> <li>Bottom silk</li> <li>Top centroid</li> <li>Board outline</li> <li>DRD (drill file)</li> </ul> </li> <li>Open in a gerber file viewer (GerbV, ViewMate)</li> <li>Check to see if each layer contains what you expect (traces, pours, holes)</li> <li>Ensure correct placement of all layers (check whether visually stacks up correctly)</li> </ul>"},{"location":"hardware/hardware/pcb_checklist/#pcba-design-reminders","title":"PCBA DESIGN REMINDERS","text":"<ul> <li>Nets named correctly (by function or pins).</li> <li>Lay down ground plane, only after ground traces.</li> <li>Check orientation of mating connectors in associated designs</li> </ul>"},{"location":"hardware/hardware/pcba/","title":"PCB/A Dev","text":""},{"location":"hardware/hardware/pcba/#step-0-kick-off-development-cycle","title":"Step 0: Kick-off Development Cycle","text":"<p>The kick-off is essential to inform everyone that the object is now in-flight for another development cycle.  The steps for kick-off are:</p> <ul> <li>Nominate a \"person in charge\" to manage this object through the process.</li> <li>Send an announce email to the development group.</li> <li>Schedule kick-off meeting</li> <li>Create a JIRA epic for the object.  E.g. \"CHECON-PCBA-New Display\"</li> <li>Create relevant JIRA stories</li> <li>Go to the hardware release page and update the relevant information for the device and any relevant sub-component projects: Current and Planned Hardware Releases</li> <li>Print this page and make sure it follows the device through the development cycle.</li> <li>Read with a pen!</li> </ul>"},{"location":"hardware/hardware/pcba/#step-1-create-design-artifacts-engineer","title":"Step 1: Create Design Artifacts (Engineer)","text":"<p>The first step to the design and manufacture of a PCB/A is to create all of the relevant design and production artifacts (files). EagleCAD schematic</p> <p>The first step for any new design is to capture it as an EagleCAD schematic.  This is the architectural design document of the circuit.  The schematic contains all of the parts in the design and is the central source of the BOM for any design by capturing component annotations.  (Later we'll get these annotations from Octopart).  The format for naming our designs is to use a six-character code like POSCTL and then the design files will be POSCTL.sch and POSCTL.brd, etc. EagleCAD layout</p> <p>Once the schematic is complete we layout the physical board in what will become the final PCB.  This layout includes the board stack-up, because each layer of the stackup is a layer in EagleCAD.  Once the layout is complete, EagleCAD can generate the Gerber files, Excellon Drill files, Centroid files and BOM for the design that are suitable to manufacture the board to completion.  For this reason any version of the EagleCAD file stored in git should always be able to generate the master files needed to manufacture the part.</p>"},{"location":"hardware/hardware/pcba/#step-2-run-erc-drc-checks-against-manufacturer-capabilities-file","title":"Step 2: Run ERC / DRC checks against manufacturer capabilities file","text":"<p>EagleCAD has the ability to create a design rules check file, and it should match your manufacturer's capabilities for the kind of board you want to make. It's a good idea to have both a \"standard\" and \"advanced\" DRC file. The standard file should be for everything that's easy to run (and somewhat cheap). The advanced file should be for when you have tight tolerances, for example when you need narrow vias. Because we are able to cut our own PCBs on a mill, we generally use \"standard\" to match the mill's capability since it's usually much looser than the \"low cost\" option at most fab houses. Advanced designs are usually beyond the capability of our mill, or require the machine operator to make special allowances for end mills. (Generally we do not run 0.025mm end mills because they break easily and are somewhat finicky.)</p>"},{"location":"hardware/hardware/pcba/#step-3-create-a-prototype-release","title":"Step 3: Create a Prototype Release","text":"<p>To validate the design we produce an in-house prototype.  This is a somewhat lightweight process where the engineer commits the Eagle schematic and board files to git.  This is not a tagged release, because there may be many of them.  </p> <ul> <li>The engineer commits the Eagle schematic and board files.</li> <li>The engineer creates a PCB blank template and mails it to the prototype shop manager.</li> <li>The engineer creates a prototype BOM and mails is to the prototype shop manager.</li> <li>The prototype shop manager schedules the board build and coordinates with the production manager to acquire any missing BOM components.</li> <li>The prototype shop converts the Eagle board file into gcode using the \"board blank\" template.</li> <li>The prototype shop cuts the PCB.</li> <li>The prototype shop assembles the PCB, that potentially includes new enclosures and mechanicals, and delivers it to the HWTE.</li> </ul> <p>When boards cannot be prototyped in-house:</p> <ul> <li>Email production files to the ProdMgr along with requested turnaround time and quantities. </li> <li>RFQs will be placed.</li> <li>Prototypes will be made at a CMS.</li> </ul> <p>Any sub-assembly which versions separately can be released (to prototype or production) without releasing the other components of the assembly.</p>"},{"location":"hardware/hardware/pcba/#step-4-test-the-prototype","title":"Step 4: Test the Prototype","text":"<p>The HWTE runs all of the relevant tests to validate that the prototype is correct.</p> <ul> <li>Program and test the device in the manufacturing/test jig.</li> <li>Run the MAT, if possible.</li> <li>Run the device in the AMT (units tests and E2E tests)</li> </ul> <p>If the HWTE approves the device for production, then proceed to step 4, otherwise go back to step 1.</p>"},{"location":"hardware/hardware/pcba/#step-5-create-the-pre-releaserelease-package-engineer","title":"Step 5: Create the Pre-Release/Release Package (Engineer)","text":"<p>There are steps to manufacturing a complete PCB/A that the EagleCAD files do not capture.  These include how to resolve ambiguity in the silkscreen (when parts are very close together), any special instructions, UL documentation, PCB stackup notes such as fiberglass type (eg. FR4, copper weights, etc.).</p> <p>Note on fab files from the CMS:</p> <p>Specify board material, surface finish (pads), electrical (nickel, gold), mask, thickness, already have a drill file, net list testing by fab shop is required. Controlled impedance is not standard \u2013 if you don\u2019t want it, don\u2019t include in notes. Include UL related notes for agency approvals \u2013 it\u2019s standard for fab shops. We should have UL in drawings and require it in boards. Need for UL has to do with plugging into the wall and certifying for safety. Also, there are specific components that need to be UL rated. All components are UL certified. If we don\u2019t specify, we don\u2019t have a document trail and can get dinged if anybody asks. Term is something about UL flammability rating as an etch on the board.</p> <p>For a PCB/A manufacturing run, the release package contains the following documents.  The file names derive from the base product ID, e.g. POSCON.  From that all PCB/A files end in POSCON.PCB.</p> File Example Prod/Design Folder Schematic POSCON.PCB.sch Design Board POSCON.PCB.brd Design Board Outline POSCON.PCB.FAB Production\\Gerber Top Copper POSCON.PCB.LAY1 Production\\Gerber Inner Copper 1 POSCON.PCB.LAY2 Production\\Gerber Inner Copper 2 POSCON.PCB.LAY3 Production\\Gerber Bottom Copper POSCON.PCB.LAY4 Production\\Gerber Bottom Soldermask POSCON.PCB.SMB Production\\Gerber Top Soldermask POSCON.PCB.SMT Production\\Gerber Bottom Solderpaste POSCON.PCB.SPB Production\\Gerber Top Solderpaste POSCON.PCB.SPT Production\\Gerber Top Silkscreen POSCON.PCB.SST Production\\Gerber Bottom Silkscreen POSCON.PCB.SSB Production\\Gerber Excellon Drill File POSCON.PCB.drd Production\\Gerber Centroid File POSCON.PCB_centroid.csv Production\\Gerber BOM POSCON.PCB.BOM.xlsx Production Fabrication Notes POSCON.PCB.FAB.txt Production Assembly File POSCON.PCB.ASSY.txt Production Test File POSCON.PCB.TEST.txt Production ECO POSCON.PCB.ECO.xlsx Production"},{"location":"hardware/hardware/pcba/#step-6-commit-the-pre-release-package-to-git-engineer","title":"Step 6: Commit the Pre-Release Package to Git (Engineer)","text":"<ul> <li>Commit the above files to github.</li> <li>Tag the commit ID (the git commit SHA1) as a release candidate (RC).  E.g. V1.1-RC1</li> </ul>"},{"location":"hardware/hardware/pcba/#step-7-release-checklist-engineer-hwte-and-prodmgr","title":"Step 7: Release Checklist (Engineer, HWTE and ProdMgr)","text":"<p>All files in the Release Candidate repository must be checked against a printed Release Checklist and a printed copy of this document for completeness and accuracy. </p> <p>Checklist: Codeshelf EE Design Process and Release</p>"},{"location":"hardware/hardware/pcba/#step-8-release-tag-engineer","title":"Step 8: Release Tag (Engineer)","text":"<p>This step includes a complete review of the design and BOM. When the checklist is passed, the Git repository will be tagged as a release.</p>"},{"location":"hardware/hardware/pcba/#step-9-arena-prodmgr","title":"Step 9: Arena (ProdMgr)","text":"<p>At this point we have an object that is manufacturable and if it passes all pre-production tests it will never, ever change again.  For this reason it is now safe to enter all pre-release package files into the Arena database before continuing the release process.  Reference the Arena process document at:"},{"location":"hardware/hardware/pcba/#step-10-build-first-articles-prodmgr","title":"Step 10: Build First Articles (ProdMgr)","text":"<p>Once a part releases prior to manufacture we send the release package to the CMS for a request to quote/manufacture.   The CMS is not allowed to make any changes to this package, including vendor or part substitutions, without first looping back to Codeshelf to obtain an ECO.  The most common case is that the CMS requests permission to swap parts or vendors for passives.  When we receive the ECR from the CMS, we review it and decide if we will approve the change.  If we agree to approve the change then we capture that change into the appropriate documents (BOM, ECO, etc.) and re-release the product with these changes.</p> <p>When the device comes back from the fab, it gets assembled by the prototype shop (if not already assembled by the outside CMS). </p> <p>Check whether CMS has any modifications to the design. If so, the design needs to be revised and re-versioned. </p>"},{"location":"hardware/hardware/pcba/#step-11-test-and-validate-first-articles-hwte","title":"Step 11: Test and Validate First Articles (HWTE)","text":"<ul> <li>Program and test the device in the manufacturing/test jig.</li> <li>Run the MAT, if possible.</li> <li>Run the device in the AMT (units tests and E2E tests)</li> </ul> <p>If approved for production then the proceed to step 12, otherwise proceed to step 1.</p>"},{"location":"hardware/hardware/pcba/#step-12-release-announcement-prodmgr","title":"Step 12: Release Announcement (ProdMgr)","text":"<p>If the First Articles are proven good, a release announcement will be issued, the Current and Planned Hardware Releases document will be updated, and the item will be cleared for further production.</p>"},{"location":"hardware/hardware/pcba/#step-13-post-release-review-prodmgr","title":"Step 13: Post Release Review (ProdMgr)","text":"<ul> <li>Review the release process with the Engineer</li> <li>Change the release process document as needed</li> <li>Change the release checklists as needed</li> </ul>"},{"location":"hardware/hardware/process_improvement/","title":"Reminder: review with the following in mind","text":"<ul> <li>Establish baseline workload for releases so they can be used to plan future work</li> <li>Identify highest friction areas that can be improved with substantial positive impact</li> <li>Make sure everyone is comfortable with the process and tools at hand</li> <li>Share tips with other teams to help each other improve their process.</li> </ul>"},{"location":"hardware/hardware/process_improvement/#review-process-through-following-lenses","title":"Review process through following lenses:","text":"<ul> <li>Are there parts of the process that we can automate with a worthwhile outcome?</li> <li>Are there steps in the process that can be reworked, improved or eliminated (last resort)</li> <li>Are there things I personally need in order to proficiently complete the process or work that is better suited for someone else shared among teams?</li> <li>Is there anything missing from the process which would help ensure that our released products are correct and portable.</li> </ul>"},{"location":"hardware/hardware/process_improvement/#facts-about-grabcad","title":"Facts about GrabCAD:","text":"<ul> <li>GrabCAD's position is that 2D drawings are dead, and they don't support them in any way other than making it possible to package PDFs along with 3D files when you get ready to submit them to a manufacturer via their Partner Spaces feature. There is no \"annotation layer\" in GrabCAD, nor do they make it possible to edit drawings in any of their tools. I have this in email from GrabCAD themselves.</li> <li>They do have a 3D view with annotations you can add, but as someone who's worked in a machine shop I sincerely question their usefulness (machine shops are likely to request PDFs for estimating purposes whether we use this tool or not). Very often prototyping machinists simply print and mark up the drawings. </li> <li>The Partner Spaces could be useful, but all they do is provide a secure landing page with a download link for manufacturing partners. </li> <li>They provide versioning, but it's not very flexible and doesn't work the way we do. It literally appends a version number to each save you upload to GrabCAD Workbench. It doesn't give us the option to use our own version number and revision scheme.</li> <li>Also, there is a provision for creating BOMs. Also not terribly flexible, nor does it have very many features that we need. What it does is kick out a CSV file with the names of the files you've uploaded, with data about those. It won't filter the filetype out of the name when it creates the CSV.  It would take me longer to hand-edit one of these (I did try!) into a workable * BOM than it would be to simply copy-paste or work from a pre-built template of our making.</li> <li>The things it does do well<ul> <li>Keeping track of historical versions of a file (every save is captured). However, we already do a form of this with Git. I haven't yet looked into what happens when you work out of the Git folder with Solidworks yet, but I suspect it'll work fine.</li> <li>Allowing for visually checking differences between two versions of a 3D CAD file (Github doesn't do this - yet)</li> <li>The things we were hoping to automate with it, BOMs and 2D drawings, are either not possible or more work than they're worth.</li> </ul> </li> </ul>"},{"location":"hardware/hardware/process_improvement/#facts-about-solidworks","title":"Facts about Solidworks:","text":"<ul> <li>There are a couple of tools that could help us work more efficiently, but they are unlikely to have a huge impact on the amount of time that we spend making drawings to the degree that it's worth slowing down the modeling process. Also, they have up-front setup times that we will need to be conscious of.</li> <li>It's possible to set up Solidworks to create BOMs that can be exported along with the drawings. This is probably a one-time endeavor, and will result in something that we can use over and over again. I'm not sure how long it would take to set up, but's unlikely to less than one day.</li> <li>It's possible to build Solidworks models in such a way as to start the process of adding annotations while one is working in the model, long before the drawings are started. Although I haven't tried this technique out yet, my suspicion is that working in this way will slow down the modeling process enough to mitigate any time savings we might get from it on the back end (i.e. annotating and preparing 2D drawings after the modeling is done). </li> </ul>"},{"location":"hardware/hardware/process_improvement/#things-that-should-go-into-current-process","title":"Things that should go into current process:","text":"<ul> <li>BOMs should be created and maintained from Solidworks (see risks/benefits below)</li> <li>Examine drawings in terms of what has changed, only test against what has changed STEP ADDED</li> <li>Bring all CAD files together into the same place (GrabCAD?) and practice better &amp; more disciplined data hygiene STEP ADDED</li> <li>Use Github at the point of file creation to reduce shuttle time between machines STEP ADDED</li> <li>Upload files to GrabCAD STEP ADDED</li> <li>Diff files and folders STEP ADDED</li> </ul>"},{"location":"hardware/hardware/process_improvement/#for-discussion-and-potential-adoption","title":"For discussion and potential adoption:","text":"<ul> <li>MECH Release Checklist Google Form<ul> <li>Cost <ul> <li>Minimal</li> </ul> </li> <li>Benefits<ul> <li>speed up and simplify the checklist process by gating out irrelevant steps in the process</li> </ul> </li> <li>Risks<ul> <li>\"Read With A Pen\" and \"No Gating\" are requirements of our current process. Should we re-examine this?</li> </ul> </li> </ul> </li> <li> <p>BOM</p> <ul> <li>Solidworks <ul> <li>Steps to a BOM         1. Do work in the model         2. Make changes         3. Changes to model are associative - no work necessary on BOM document         4. Print along with drawings</li> </ul> </li> <li>Benefits <ul> <li>Very little work need be done if proper setup </li> <li>Associative (BOM changes along with model)</li> </ul> </li> <li>Risks<ul> <li>CAD data used in production models must be 1:1 match to design intent (all parts must be the ones being specified)</li> <li>Errors might be time-consuming to correct</li> </ul> </li> <li>Requirements<ul> <li>BOM template must be created</li> <li>Project CAD data must be robust (part numbers correct, etc.)</li> <li>In order to evaluate potential time savings, it might be necessary to create a prototype BOM </li> </ul> </li> </ul> </li> <li> <p>Solidworks Design Checker </p> <ul> <li>http://www.solidworks.com/sw/products/3d-cad/cad-standards-checking-and-drawing-comparison.htm</li> <li>Cost<ul> <li>Upgrade to Solidworks Professional</li> <li>Setup time for templates </li> </ul> </li> <li>Time Savings<ul> <li>Reducing the drawing examination to a push-button process</li> </ul> </li> <li>Benefits<ul> <li>Simplifying the process of checking drawings dramatically</li> </ul> </li> <li>Risks         It might take a while to figure out a good set of rules to build in to the Design Checker         Upfront build might be expensive in terms of labor         Only checks what you tell it to check</li> </ul> </li> <li> <p>What's it going to take to implement this? What's the cost? What's the benefit? What's the risk?</p> </li> <li>How is the process testable against our baseline?</li> <li>How do these changes impact time to completion?</li> </ul> <p>Documents and associated tools:</p> <ul> <li>Drawings<ul> <li>Created using Solidworks</li> </ul> </li> <li>BOM<ul> <li>Created/updated in LibreOffice</li> </ul> </li> <li>ECO<ul> <li>Created/updated in LibreOffice</li> </ul> </li> <li>README files<ul> <li>Created/updated in LibreOffice</li> </ul> </li> </ul> <p>Mech release automation</p> <p>Suggestions: * for 2D Drawings     * Set up templates in such a way as to minimize front-end work * Model-Based Definition (3D PDF)     * This is a method of CAD model data output that creates a package that is highly portable     * http://www.solidworks.com/sw/products/technical-communication/solidworks-mbd.htm</p> <p>Design Checker is an add-in for Solidworks Professional that allows for rule-based 'diff' operations on Solidworks drawings. Requires that an operator identifies the parts of the drawing that need to conform to standards (e.g. dimensions can not cross one another, can not be less than \u215c\" from the model itself, etc.)</p> <p>Currently, we would need a license upgrade to Professional to try this add-in. I might need to speak with a Solidworks Rep in order to determine if this is a good fit for our needs/worth the upgrade.</p> <p>Additionally, Professional comes with a huge CAD Toolbox that has thousands of pre-built fasteners (which would speed things up - the operator would spend far less time searching McMaster for CAD files)</p> <p>http://www.solidworks.com/sw/products/3d-cad/cad-standards-checking-and-drawing-comparison.htm</p> <p>http://www.solidworks.com/sw/products/3d-cad/cad-library.htm Mech Acceptance/Conformance Testing</p> <p>Basic Hardware Testing Criteria</p> <p>Document here:</p> <p>https://docs.google.com/document/d/1ZpMAv2LG8mZiS7Jtf1E0wzCPsQbAyp7QIwp0flFzmjo/edit</p>"},{"location":"hardware/hardware/process_improvement/#cad-standards","title":"CAD standards","text":"<p>Solidworks models built for production purposes ought to fulfill the following criteria:</p> <ul> <li>1:1 match with production object (This ensures that the BOM and other associated files are accurate)</li> <li>Design work is complete before Solidworks work is begun (dimensions are final, any formal studies are complete, etc.)</li> <li>Solidworks models are uploaded to GrabCAD<ul> <li>For change-tracking</li> <li>To enable multiple users to work on the models concurrently/separately</li> </ul> </li> </ul>"},{"location":"hardware/hardware/top_level/","title":"Top-Level Object Dev","text":"<p>The purpose of this document is to describe the process for a major revision or creating a new object. The top level party should hold on to this document and use it to organized the development of the object. During the process please write on the document improvements and alterations.</p>"},{"location":"hardware/hardware/top_level/#step-0-kick-off-development-cycle","title":"Step 0: Kick-off Development Cycle","text":"<p>The kick-off is essential to inform everyone that the object is now in-flight for a development cycle.</p> <ul> <li>Send an announce email to development group that includes the PLM narrative of the object</li> <li>Schedule a kick-off meeting and invite whomever will be involved</li> <li>Create a top level Github repository if necessary</li> <li>Create a JIRA epic for the object \u201ce.g. CHECON- New Display\u201d</li> <li>Print this document</li> <li>Fill out the top portion</li> <li>Top level party should hold on to this document, check, and red pen as the project moves</li> </ul>"},{"location":"hardware/hardware/top_level/#step-1-kick-off-meeting","title":"Step 1: Kick-off Meeting","text":"<p>The purpose of this step is to identify and start coordinating development of all sub and co components of this top level object.</p> <ul> <li>Go over design stories that this object will accomplish</li> <li>Define the sub-components and co-components of the top level object<ul> <li>Examples include:<ul> <li>PCB/A</li> <li>Mechanicals</li> <li>Firmware</li> </ul> </li> <li>For sub-components and co-components that will need development for this project<ul> <li>Assign top level parties to each component who will run those development cycles</li> </ul> </li> </ul> </li> <li>Go to hardware release page and update the relevant information for the top level device, relevant sub-components, and co-components"},{"location":"hardware/hardware/top_level/#step-2-sketch-session","title":"Step 2: Sketch Session","text":"<p>A sketch sessions should be conducted for mid to large-sized projects or problems where the requirements and solutions are still ambiguous. Sessions include the lead stakeholder (client), product owner, domain experts, designers and facilitators. The group works together on diverging ideas around the problem space, then pair the ideas down to ones that are actionable.</p> <p>If the object owners decide a sketch session would be helpful have a sketch session. If the problem and/or solution is ambiguous then a sketch session is recommended - otherwise if the solution is unambiguous probably not needed.</p>"},{"location":"hardware/hardware/top_level/#step-3-define-a-six-digit-alpha-code","title":"Step 3: Define a six digit alpha code","text":"<p>If necessary define a new six digit alpha code. Part numbering scheme will probably change copy from other document</p>"},{"location":"hardware/hardware/top_level/#step-4-product-lifecycle-update-testability","title":"Step 4: Product Lifecycle Update / Testability","text":"<p>Every finished goods object we produce includes an informal product lifecycle narrative document. The goals of the object should be reflected in the testability of the object. For each goal we should have at least one test. Each time we start a design process loop on a new or existing object we need to update the PLM narrative with answers to questions similar to:</p> <ul> <li>What are the goals of this object?</li> <li>What is testable about the object?</li> </ul>"},{"location":"hardware/hardware/top_level/#step-7-coordinate-the-sub-components-and-co-components-development","title":"Step 7: Coordinate the sub-components and co-components development","text":"<p>This is the actual development of all the sub and co components of the top level device. This step could take a very long time depending on the scope of the project. During this time the top level party of this device is responsible for fostering communication between all the sub and co component top level parties so development is as seamless as possible.</p> <ul> <li>Have regular meetings with at least all of the sub-component and co-component top level parties to discuss the state of this top level object</li> <li>The top level party of this object should be made aware of any changes the sub and co components development path so they can be a single point of information (fostering communication)</li> <li>Make sure sub-components and co-components are working towards accomplishing the design stories</li> </ul>"},{"location":"hardware/hardware/top_level/#step-8-verify-all-released-sub-components-and-co-components","title":"Step 8: Verify all released Sub-components and Co-Components","text":"<p>The purpose of this step is to verify that the top level party of this object has all the parts they need to do a top level release.</p> <ul> <li>When all the sub-components and co-components have finished their development cycles have a meeting with all the sub-component top level parties and verify the finished top level object.</li> <li>Verify that all the sub and co components have have released all the parts required to do a top level object</li> <li>Did the related components actually follow the release process?</li> <li>Are they actually released? </li> <li>Identify any additional parts that need to be created for top level object release</li> <li>Create a finished goods checklist</li> <li>Combine all the sub and co components</li> </ul>"},{"location":"hardware/hardware/top_level/#step-9-create-the-production-package","title":"Step 9: Create the Production Package","text":"<ul> <li>Create the appropriate production package for this device. In general the production package should include at least a BOM and a ECO - it may also include testing information and packaging information.</li> <li>Make sure that the file names in the repository match the names in the BOM</li> <li>To the extent that is possible the editable versions of the documents should also be put in the Github repository. (e.g. The editable document used to produce a PDF should be also included)</li> </ul>"},{"location":"hardware/hardware/top_level/#step-10-release-top-level","title":"Step 10: Release Top Level","text":"<p>We need a barebones checklist - ask calla</p> <ul> <li>Add all finished files to Github repository for this object</li> <li>Release the object by tagging the commit</li> <li>Announce the release to oakland-staff@codeshelf.com </li> <li>Update the release status page</li> </ul>"},{"location":"hardware/hardware/top_level/#step-11-post-release-review-prodmgr","title":"Step 11: Post Release Review (ProdMgr)","text":"<ul> <li>Review the release process with the Engineer</li> <li>Change the release process document as needed</li> <li>Change the release checklists as needed</li> </ul>"},{"location":"hardware/test/monkey/","title":"Automated Monkey Tests","text":""},{"location":"hardware/test/monkey/#automated-monkey-testing-amt","title":"Automated Monkey Testing (AMT)","text":"<p>A continuous and complete simulation of user interactions against a design. You run automated monkey tests against each commit using the continuous integration (CI) system. </p> <p>The alternative, perhaps most common way to accomplish this kind of testing, is human-scripted testing. </p> <p>Don't do that! </p> <p>Human-driven, scripted testing is mindless and boooring, and the more someone runs them, the more numb they become. This is a recipe for tests that hardly ever get run, and when they do get run, the effort is generally perfunctory and sloppy.</p>"},{"location":"hardware/test/monkey/#even-your-first-design-iteration-should-be-testable","title":"Even your first design iteration should be testable","text":"<p>When you engage in any design, you must start with the question: \"what's testable about this design?\"</p> <p>The right way to test is automation: continuous integration, unit and end-to-end tests. You'll never get to automated testing unless the tests are part of the design process. A side benefit of doing this in the design process is that when you send a revision to mass production, your vendor partners have a way to validate their work as part of the QA/acceptance testing. (You, really, really, really don't want to race around trying to create some kind of manufacturing acceptance test just before manufacture because it will force you to redesign the PCB and that will take almost as much work as the original development!)</p>"},{"location":"hardware/test/monkey/#test-criteria-fall-into-four-broad-categories","title":"Test criteria fall into four broad categories:","text":""},{"location":"hardware/test/monkey/#usability","title":"Usability","text":"<p>The whole reason to follow the ZeroDiff process is to rapidly iterate on your design assumptions. The design stories that flow out of the sprints should represent the base criteria that validates if the design meets user need. As soon as a prototype emerges from the shop, the test team needs to validate the prototype against these stories.</p>"},{"location":"hardware/test/monkey/#survivability","title":"Survivability","text":"<p>One problem with the \"works-like/looks-like\" development model is there is no way to know how difficult it will be to design a production version that can survive contact with users. Breaking the production process into two phases like this will take more total development hours, and it creates a lot of uncertainty about how long it will actually take to get to market.</p>"},{"location":"hardware/test/monkey/#manufacturability","title":"Manufacturability","text":"<p>Each time the prototype team produces a design iteration, they should perform a design-for-manufacture (DMF) review. Each iteration is a chance for the production team to inform the design team of ways to improve costs, simplicity, reliability and quality. One nice thing about the ZeroDiff process is that small changes like this are easy to digest, so the two teams can make a lot of progress without conflict.</p>"},{"location":"hardware/test/monkey/#reliability","title":"Reliability","text":"<p>Probably the most unnerving part of hardware development are transient field failures. E.g. glitches, reboots, freezes, bricking or random weirdness in the user experience. The best way to defend against transient failures is to force the combined firmware and hardware through automated testing for every commit.</p>"},{"location":"hardware/test/monkey/#steps-to-get-to-amt","title":"Steps to get to AMT","text":""},{"location":"hardware/test/monkey/#burn-inmanufacture-jigs","title":"Burn-in/Manufacture Jigs","text":"<p>Probably the easiest way to start down the road to AMT is to start with a test/flash jig for any new design. Resist the temptation to simply place a JTAG/SWD header on the PCB that fits your programming pod. It will be difficult for an outside vendor partner to reach any meaningful scale if they require access to a programming pod on the manufacturing floor. Even if you don't have the ability to fabricate a jig now, the presence of the flash/debug bus as test points means you can more easily automate this for production later without having to redesign the board. Whether the device ever reaches scaled production or not, it costs almost nothing to add this capability in the beginning.</p>"},{"location":"hardware/test/monkey/#test-harness-and-test-points","title":"Test Harness and Test Points","text":"<p>Closely related to burn-in jigs are test points. Any I/O, button, switch, sensor or communication bus should have a corresponding test point (pad) accessible somewhere on the PCB. These should all be on the same side, probably on what would be the \"bottom\" if the device has a strong user-facing side. The test harness can use pogo-pins to reach these test points. Even if you don't have the capability to fabricate a test harness/jig, adding these test points now allows you easily incorporate a test harness later without having to redesign the board.</p> <p>Eventually you want these test points to drive automated tests that simulate user behaviors to test on-board subsystems like communications or sensor readings. The same automated, scripted tests you use in AMT work for manufacturing validation and QA. The assembly line worker should be able to push the completed device into a harness and press a button that flashes the device and runs a validation battery that results in a go/no-go indication for the assembly worker.</p>"},{"location":"hardware/test/monkey/#scripted-development-environment","title":"Scripted Development Environment","text":"<p>Almost all firmware development toolchains now support scripted development. Embrace this early and integrate it into a continuous integration tool like TeamCity. This is not hard to do, and the benefits are enormous. Once the scripted testing is in place, your development team has a convenient place to hang firmware unit tests. Scripted testing is also a good place to hang automated monkey tests. Once you have even one of these automated tests, it's much easier for the team to add subsequent tests.</p>"},{"location":"hardware/test/monkey/#report-bugs-as-unit-tests","title":"Report Bugs as Unit Tests","text":"<p>A good QA and development team is able to express bugs as unit or E2E tests that fail. Having a place to add these tests to automated testing means that you can get coverage against regressions or closely related failures.</p>"},{"location":"software/","title":"Software","text":""},{"location":"blog/archive/2025/","title":"December 2025","text":""}]}